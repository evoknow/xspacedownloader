#!/usr/bin/env python3
"""
XSpace Downloader - Production Deployment Script

This script automates the deployment of XSpace Downloader to a production server.
It handles nginx configuration, systemd services, and initial setup.

Usage:
    python3 deploy.py --nginx-user=nginx --production-dir=/var/www/xspacedownload \
                      --nginx-etc-dir=/etc/nginx --domain=xspacedownload.com

"""

import os
import sys
import argparse
import shutil
import subprocess
from pathlib import Path


class Deployer:
    def __init__(self, args):
        self.nginx_user = args.nginx_user
        self.production_dir = args.production_dir
        self.nginx_etc_dir = args.nginx_etc_dir
        self.systemd_dir = args.systemd_dir
        self.domain = args.domain
        self.port = args.port
        self.workers = args.workers
        self.dry_run = args.dry_run
        self.current_dir = Path(__file__).parent.absolute()
        
    def run_command(self, cmd, shell=False, check=True):
        """Execute a command, respecting dry-run mode."""
        if self.dry_run:
            print(f"[DRY RUN] Would execute: {cmd}")
            return
        
        try:
            if shell:
                result = subprocess.run(cmd, shell=True, check=check, capture_output=True, text=True)
            else:
                result = subprocess.run(cmd, check=check, capture_output=True, text=True)
            
            if result.stdout:
                print(result.stdout)
            if result.stderr:
                print(result.stderr, file=sys.stderr)
                
            return result
        except subprocess.CalledProcessError as e:
            print(f"Error executing command: {e}")
            if e.stdout:
                print(f"stdout: {e.stdout}")
            if e.stderr:
                print(f"stderr: {e.stderr}")
            raise
    
    def create_nginx_config(self):
        """Generate nginx configuration file."""
        print("\n=== Creating nginx configuration ===")
        
        nginx_config = f"""# XSpace Downloader - Nginx Configuration
# Auto-generated by deploy.py

server {{
    listen 80;
    server_name {self.domain} www.{self.domain};

    # Redirect HTTP to HTTPS (uncomment after SSL setup)
    # return 301 https://$server_name$request_uri;

    location / {{
        proxy_pass http://127.0.0.1:{self.port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeouts for long-running operations
        proxy_connect_timeout 600;
        proxy_send_timeout 600;
        proxy_read_timeout 600;
        send_timeout 600;
    }}

    location /static {{
        alias {self.production_dir}/static;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}

    location /downloads {{
        alias {self.production_dir}/downloads;
        # Optional: Add authentication
        # auth_basic "Restricted";
        # auth_basic_user_file /etc/nginx/.htpasswd;
    }}
    
    # Larger file uploads
    client_max_body_size 500M;
}}

# HTTPS configuration (uncomment after obtaining SSL certificate)
# server {{
#     listen 443 ssl http2;
#     server_name {self.domain} www.{self.domain};
#
#     ssl_certificate /etc/letsencrypt/live/{self.domain}/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/{self.domain}/privkey.pem;
#     ssl_protocols TLSv1.2 TLSv1.3;
#     ssl_ciphers HIGH:!aNULL:!MD5;
#     ssl_prefer_server_ciphers on;
#
#     # Security headers
#     add_header X-Frame-Options "SAMEORIGIN" always;
#     add_header X-Content-Type-Options "nosniff" always;
#     add_header X-XSS-Protection "1; mode=block" always;
#     add_header Referrer-Policy "no-referrer-when-downgrade" always;
#
#     location / {{
#         proxy_pass http://127.0.0.1:{self.port};
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection 'upgrade';
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_cache_bypass $http_upgrade;
#         
#         proxy_connect_timeout 600;
#         proxy_send_timeout 600;
#         proxy_read_timeout 600;
#         send_timeout 600;
#     }}
#
#     location /static {{
#         alias {self.production_dir}/static;
#         expires 30d;
#         add_header Cache-Control "public, immutable";
#     }}
#
#     location /downloads {{
#         alias {self.production_dir}/downloads;
#     }}
#     
#     client_max_body_size 500M;
# }}
"""
        
        nginx_sites_available = Path(self.nginx_etc_dir) / "sites-available"
        nginx_sites_enabled = Path(self.nginx_etc_dir) / "sites-enabled"
        config_file = nginx_sites_available / "xspacedownloader"
        
        if self.dry_run:
            print(f"[DRY RUN] Would write nginx config to: {config_file}")
            print("Config content:")
            print(nginx_config)
        else:
            # Create directories if they don't exist
            nginx_sites_available.mkdir(parents=True, exist_ok=True)
            nginx_sites_enabled.mkdir(parents=True, exist_ok=True)
            
            # Write config file
            with open(config_file, 'w') as f:
                f.write(nginx_config)
            print(f"Created nginx config: {config_file}")
            
            # Create symlink
            symlink = nginx_sites_enabled / "xspacedownloader"
            if symlink.exists():
                symlink.unlink()
            symlink.symlink_to(config_file)
            print(f"Created symlink: {symlink}")
    
    def create_systemd_services(self):
        """Generate systemd service files."""
        print("\n=== Creating systemd services ===")
        
        # Main application service
        app_service = f"""[Unit]
Description=XSpace Downloader Web Application
After=network.target mysql.service
Wants=mysql.service

[Service]
Type=simple
User={self.nginx_user}
Group={self.nginx_user}
WorkingDirectory={self.production_dir}
Environment="PATH={self.production_dir}/venv/bin:/usr/local/bin:/usr/bin:/bin"
Environment="PYTHONPATH={self.production_dir}"
Environment="PORT={self.port}"
ExecStart={self.production_dir}/venv/bin/python {self.production_dir}/app.py
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths={self.production_dir}/downloads {self.production_dir}/logs {self.production_dir}/transcript_jobs {self.production_dir}

# Logging
StandardOutput=append:{self.production_dir}/logs/app.log
StandardError=append:{self.production_dir}/logs/app-error.log

[Install]
WantedBy=multi-user.target
"""

        # Gunicorn service
        gunicorn_service = f"""[Unit]
Description=XSpace Downloader Web Application (Gunicorn)
After=network.target mysql.service
Wants=mysql.service

[Service]
Type=notify
User={self.nginx_user}
Group={self.nginx_user}
WorkingDirectory={self.production_dir}
Environment="PATH={self.production_dir}/venv/bin:/usr/local/bin:/usr/bin:/bin"
Environment="PYTHONPATH={self.production_dir}"
ExecStart={self.production_dir}/venv/bin/gunicorn app:app -c {self.production_dir}/gunicorn.conf.py
ExecReload=/bin/kill -s HUP $MAINPID
KillMode=mixed
TimeoutStopSec=5
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths={self.production_dir}/downloads {self.production_dir}/logs {self.production_dir}/transcript_jobs {self.production_dir}

[Install]
WantedBy=multi-user.target
"""

        # Background downloader - DISABLED by default
        # These services are disabled by default because they're optional and resource-intensive
        # Enable them if you want automatic background processing
        bg_service = f"""[Unit]
Description=XSpace Downloader Background Downloader
After=network.target mysql.service
Wants=mysql.service

[Service]
Type=simple
User={self.nginx_user}
Group={self.nginx_user}
WorkingDirectory={self.production_dir}
Environment="PATH={self.production_dir}/venv/bin:/usr/local/bin:/usr/bin:/bin"
Environment="PYTHONPATH={self.production_dir}"
ExecStart={self.production_dir}/venv/bin/python {self.production_dir}/bg_downloader.py
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths={self.production_dir}/downloads {self.production_dir}/logs {self.production_dir}/transcript_jobs {self.production_dir}

# Logging
StandardOutput=append:{self.production_dir}/logs/bg_downloader.log
StandardError=append:{self.production_dir}/logs/bg_downloader-error.log

[Install]
WantedBy=multi-user.target
"""

        # Transcriber service - DISABLED by default
        transcribe_service = f"""[Unit]
Description=XSpace Downloader Background Transcriber
After=network.target mysql.service
Wants=mysql.service

[Service]
Type=simple
User={self.nginx_user}
Group={self.nginx_user}
WorkingDirectory={self.production_dir}
Environment="PATH={self.production_dir}/venv/bin:/usr/local/bin:/usr/bin:/bin"
Environment="PYTHONPATH={self.production_dir}"
ExecStart={self.production_dir}/venv/bin/python {self.production_dir}/background_transcribe.py
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths={self.production_dir}/downloads {self.production_dir}/logs {self.production_dir}/transcript_jobs {self.production_dir}

# Logging
StandardOutput=append:{self.production_dir}/logs/background_transcribe.log
StandardError=append:{self.production_dir}/logs/background_transcribe-error.log

[Install]
WantedBy=multi-user.target
"""
        
        services = {
            "xspacedownloader.service": app_service,
            "xspacedownloader-gunicorn.service": gunicorn_service,
            "xspacedownloader-bg.service": bg_service,
            "xspacedownloader-transcribe.service": transcribe_service
        }
        
        systemd_path = Path(self.systemd_dir)
        
        for filename, content in services.items():
            service_file = systemd_path / filename
            
            if self.dry_run:
                print(f"[DRY RUN] Would write {filename} to: {service_file}")
                print(f"Content preview for {filename}:")
                print(content[:200] + "...")
            else:
                with open(service_file, 'w') as f:
                    f.write(content)
                print(f"Created service file: {service_file}")
    
    def create_gunicorn_config(self):
        """Generate gunicorn configuration."""
        print("\n=== Creating gunicorn configuration ===")
        
        gunicorn_config = f"""# Gunicorn configuration for XSpace Downloader
# Auto-generated by deploy.py

import multiprocessing
import os

# Server socket
bind = "127.0.0.1:{self.port}"
backlog = 2048

# Worker processes
workers = {self.workers if self.workers > 0 else 'multiprocessing.cpu_count() * 2 + 1'}
worker_class = "sync"
worker_connections = 1000
timeout = 600  # 10 minutes for long-running downloads
keepalive = 2

# Restart workers after this many requests
max_requests = 1000
max_requests_jitter = 100

# Logging
accesslog = "{self.production_dir}/logs/gunicorn-access.log"
errorlog = "{self.production_dir}/logs/gunicorn-error.log"
loglevel = "info"
access_log_format = '%(h)s %(l)s %(u)s %(t)s "%(r)s" %(s)s %(b)s "%(f)s" "%(a)s" %(D)s'

# Process naming
proc_name = 'xspacedownloader'

# Server mechanics
daemon = False
pidfile = "{self.production_dir}/gunicorn.pid"
user = "{self.nginx_user}"
group = "{self.nginx_user}"
tmp_upload_dir = None

# Environment variables
raw_env = [
    "PYTHONPATH={self.production_dir}",
]

# Preload application
preload_app = True
"""
        
        config_file = Path(self.production_dir) / "gunicorn.conf.py"
        
        if self.dry_run:
            print(f"[DRY RUN] Would write gunicorn config to: {config_file}")
            print("Config content:")
            print(gunicorn_config)
        else:
            with open(config_file, 'w') as f:
                f.write(gunicorn_config)
            print(f"Created gunicorn config: {config_file}")
    
    def setup_directories(self):
        """Create necessary directories with proper permissions."""
        print("\n=== Setting up directories ===")
        
        dirs = ['logs', 'downloads', 'transcript_jobs']
        
        for dir_name in dirs:
            dir_path = Path(self.production_dir) / dir_name
            
            if self.dry_run:
                print(f"[DRY RUN] Would create directory: {dir_path}")
                print(f"[DRY RUN] Would set owner to {self.nginx_user}:{self.nginx_user}")
            else:
                dir_path.mkdir(parents=True, exist_ok=True)
                self.run_command(['chown', f'{self.nginx_user}:{self.nginx_user}', str(dir_path)])
                print(f"Created directory: {dir_path}")
    
    def set_permissions(self):
        """Set proper file permissions for security."""
        print("\n=== Setting file permissions ===")
        
        if self.dry_run:
            print(f"[DRY RUN] Would set ownership of {self.production_dir} to {self.nginx_user}:{self.nginx_user}")
            print(f"[DRY RUN] Would set .env permissions to 640")
            print(f"[DRY RUN] Would set gunicorn.conf.py permissions to 644")
        else:
            # Set ownership of entire production directory
            self.run_command(['chown', '-R', f'{self.nginx_user}:{self.nginx_user}', self.production_dir])
            print(f"Set ownership of {self.production_dir} to {self.nginx_user}:{self.nginx_user}")
            
            # Secure .env file permissions
            env_file = Path(self.production_dir) / '.env'
            if env_file.exists():
                self.run_command(['chmod', '640', str(env_file)])
                print(f"Set .env permissions to 640 (owner read/write, group read, no world access)")
            
            # Ensure config files are readable
            gunicorn_conf = Path(self.production_dir) / 'gunicorn.conf.py'
            if gunicorn_conf.exists():
                self.run_command(['chmod', '644', str(gunicorn_conf)])
                print(f"Set gunicorn.conf.py permissions to 644")
    
    def create_env_file(self):
        """Create .env file with basic configuration."""
        print("\n=== Creating .env configuration file ===")
        
        env_content = f"""# XSpace Downloader Environment Configuration
# Generated by deploy.py

# Production configuration
PRODUCTION_DIR={self.production_dir}
NGINX_USER={self.nginx_user}
DOMAIN={self.domain}
PORT={self.port}

# Debug settings (set to true to enable component logging)
DEBUG_LOGGING=false

# Email configuration (add your SendGrid API key)
SENDGRID_API_KEY=

# Database configuration (will use db_config.json)

# Add other environment variables as needed
"""
        
        env_file = Path(self.production_dir) / '.env'
        
        if self.dry_run:
            print(f"[DRY RUN] Would create .env file at: {env_file}")
            print("Content:")
            print(env_content)
        else:
            with open(env_file, 'w') as f:
                f.write(env_content)
            print(f"Created .env file: {env_file}")
            
            # Set secure permissions
            self.run_command(['chmod', '640', str(env_file)])
            print(f"Set .env permissions to 640")
    
    def deploy(self):
        """Run the deployment process."""
        print(f"XSpace Downloader Deployment Script")
        print(f"===================================")
        print(f"Nginx User: {self.nginx_user}")
        print(f"Production Directory: {self.production_dir}")
        print(f"Nginx Config Directory: {self.nginx_etc_dir}")
        print(f"Domain: {self.domain}")
        print(f"Port: {self.port}")
        print(f"Workers: {self.workers if self.workers > 0 else 'auto'}")
        print(f"Dry Run: {self.dry_run}")
        
        if not self.dry_run:
            # Check if running as root
            if os.geteuid() != 0:
                print("\nERROR: This script must be run as root (use sudo)")
                sys.exit(1)
        
        # Create production directory
        prod_path = Path(self.production_dir)
        if self.dry_run:
            print(f"\n[DRY RUN] Would create production directory: {prod_path}")
        else:
            prod_path.mkdir(parents=True, exist_ok=True)
            print(f"\nCreated production directory: {prod_path}")
        
        # Setup directories
        self.setup_directories()
        
        # Create nginx configuration
        self.create_nginx_config()
        
        # Create systemd services
        self.create_systemd_services()
        
        # Create gunicorn configuration
        self.create_gunicorn_config()
        
        # Set file permissions
        self.set_permissions()
        
        # Create .env file with configuration
        self.create_env_file()
        
        # Print next steps
        print("\n=== Deployment files created successfully! ===")
        print("\nNext steps:")
        print("1. Copy application files to production directory:")
        print(f"   sudo rsync -av --exclude='venv' --exclude='.git' --exclude='*.pyc' . {self.production_dir}/")
        print(f"   sudo chown -R {self.nginx_user}:{self.nginx_user} {self.production_dir}")
        print(f"   sudo chmod 640 {self.production_dir}/.env  # Secure environment file")
        print("\n2. Setup Python virtual environment:")
        print(f"   cd {self.production_dir}")
        print(f"   sudo -u {self.nginx_user} python3 -m venv venv")
        print(f"   sudo -u {self.nginx_user} venv/bin/pip install --upgrade pip")
        print(f"   sudo -u {self.nginx_user} venv/bin/pip install -r requirements.txt")
        print(f"   sudo -u {self.nginx_user} venv/bin/pip install gunicorn")
        print("\n3. Configure database in db_config.json")
        print("\n4. Setup environment variables in .env file (already created with basic config)")
        print(f"   sudo chmod 640 {self.production_dir}/.env  # Secure permissions")
        print("\n5. Initialize database:")
        print(f"   sudo -u {self.nginx_user} venv/bin/python db_setup.py")
        print("\n6. Test nginx configuration:")
        print("   sudo nginx -t")
        print("   sudo systemctl reload nginx")
        print("\n7. Enable and start services:")
        print("   sudo systemctl daemon-reload")
        print("   # Enable and start the main web application (required):")
        print("   sudo systemctl enable xspacedownloader-gunicorn")
        print("   sudo systemctl start xspacedownloader-gunicorn")
        print("\n   # Optional: Enable background services if you want automatic processing:")
        print("   # Note: These are disabled by default as they're resource-intensive")
        print("   # Enable them only if you need automatic download/transcription processing")
        print("   # sudo systemctl enable xspacedownloader-bg        # Auto-download spaces")
        print("   # sudo systemctl enable xspacedownloader-transcribe # Auto-transcribe audio")
        print("   # sudo systemctl start xspacedownloader-bg")
        print("   # sudo systemctl start xspacedownloader-transcribe")
        print("\n   # Alternative: Run background processes manually when needed:")
        print(f"   cd {self.production_dir}")
        print(f"   sudo -u {self.nginx_user} nohup {self.production_dir}/venv/bin/python {self.production_dir}/bg_downloader.py > /dev/null 2>&1 &")
        print(f"   sudo -u {self.nginx_user} nohup {self.production_dir}/venv/bin/python {self.production_dir}/background_transcribe.py > /dev/null 2>&1 &")
        print("\n8. Setup SSL certificate:")
        print("   sudo certbot --nginx -d {} -d www.{}".format(self.domain, self.domain))
        print("\n9. Use update.py script for future deployments:")
        print("   ./update.py  # Pulls latest code and deploys to production")


def main():
    parser = argparse.ArgumentParser(
        description='Deploy XSpace Downloader to production server',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Ubuntu/Debian with default paths
  sudo python3 deploy.py --nginx-user=www-data --production-dir=/var/www/xspacedownload \\
                         --nginx-etc-dir=/etc/nginx --domain=xspacedownload.com

  # CentOS/RHEL/Fedora with nginx user
  sudo python3 deploy.py --nginx-user=nginx --production-dir=/usr/share/nginx/xspacedownload \\
                         --nginx-etc-dir=/etc/nginx --domain=example.com

  # Amazon Linux 2 / AWS EC2
  sudo python3 deploy.py --nginx-user=nginx --production-dir=/var/www/html/xspacedownload \\
                         --nginx-etc-dir=/etc/nginx --domain=myapp.amazonaws.com

  # Custom setup with non-standard paths
  sudo python3 deploy.py --nginx-user=webuser --production-dir=/opt/apps/xspace \\
                         --nginx-etc-dir=/usr/local/nginx/conf --domain=mysite.com \\
                         --port=8000 --workers=4

  # Dry run to preview changes
  python3 deploy.py --nginx-user=www-data --production-dir=/var/www/xspace \\
                    --domain=mysite.com --dry-run
        """
    )
    
    parser.add_argument('--nginx-user', 
                        default='www-data',
                        help='Nginx/web server user (default: www-data)')
    
    parser.add_argument('--production-dir',
                        default='/var/www/xspacedownloader',
                        help='Production directory path (default: /var/www/xspacedownloader)')
    
    parser.add_argument('--nginx-etc-dir',
                        default='/etc/nginx',
                        help='Nginx configuration directory (default: /etc/nginx)')
    
    parser.add_argument('--systemd-dir',
                        default='/etc/systemd/system',
                        help='Systemd directory (default: /etc/systemd/system)')
    
    parser.add_argument('--domain',
                        required=True,
                        help='Domain name for the site (required)')
    
    parser.add_argument('--port',
                        type=int,
                        default=8080,
                        help='Port for the application (default: 8080)')
    
    parser.add_argument('--workers',
                        type=int,
                        default=0,
                        help='Number of gunicorn workers (default: auto-detect)')
    
    parser.add_argument('--dry-run',
                        action='store_true',
                        help='Show what would be done without making changes')
    
    args = parser.parse_args()
    
    # Create deployer and run
    deployer = Deployer(args)
    deployer.deploy()


if __name__ == '__main__':
    main()