{% extends "base.html" %}

{% block title %}{{ space.title if space.title else space.space_id }} - XSpace Downloader{% endblock %}

{% block head %}
<!-- Plyr CSS -->
<link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />

<!-- SummerNote CSS -->
<link href="https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-lite.min.css" rel="stylesheet">

<!-- Open Graph (used by Facebook, X, LinkedIn, etc.) -->
<meta property="og:title" content="{{ space.title if space.title else 'Space ' + space.space_id }}">
<meta property="og:description" content="Listen to this X Space recording{% if space.title %}: {{ space.title|truncate(100) }}{% endif %}">
<meta property="og:image" content="{{ request.url_root[:-1] }}/share/{{ space.space_id }}.jpg">
<meta property="og:url" content="{{ request.url }}">
<meta property="og:type" content="website">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="{{ space.title if space.title else 'Space ' + space.space_id }}">
<meta name="twitter:description" content="Listen to this X Space recording{% if space.title %}: {{ space.title|truncate(100) }}{% endif %}">
<meta name="twitter:image" content="{{ request.url_root[:-1] }}/share/{{ space.space_id }}.large.jpg">
<meta name="twitter:url" content="{{ request.url }}">

<style>
    /* Volume slider styling for better visibility */
    .form-range {
        height: 0.5rem;
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 5px;
        border: none;
    }
    
    html[data-bs-theme="dark"] .form-range {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .form-range::-webkit-slider-thumb {
        background-color: var(--bs-primary);
        border: none;
    }
    
    .form-range::-moz-range-thumb {
        background-color: var(--bs-primary);
        border: none;
    }
    
    .form-range::-webkit-slider-runnable-track {
        background-color: transparent;
    }
    
    .form-range::-moz-range-track {
        background-color: transparent;
    }
    
    /* Note item styling */
    .note-item {
        background-color: var(--bs-gray-100);
    }
    
    html[data-bs-theme="dark"] .note-item {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    /* Mobile optimizations */
    @media (max-width: 576px) {
        /* Smaller buttons on mobile */
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
        
        /* Center title on mobile */
        #space-title {
            font-size: 1.2rem;
        }
        
        /* Compact audio player controls */
        .audio-controls .btn-sm {
            padding: 0.375rem 0.75rem;
        }
        
        /* Stack metadata items vertically on mobile */
        .space-details .d-flex {
            flex-direction: column;
            align-items: start !important;
            gap: 0.5rem !important;
        }
    }
    
    /* Edit button styling */
    #edit-title-btn {
        opacity: 0.5;
        transition: opacity 0.2s;
    }
    
    #edit-title-btn:hover {
        opacity: 1;
    }
    
    /* Transcript actions styling */
    .transcript-actions {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }
    
    .transcript-section {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 1.5rem;
    }
    
    html[data-bs-theme="dark"] .transcript-section {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    .transcript-content {
        white-space: pre-wrap;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
    }
    
    /* Timestamp styling */
    .timestamp-link {
        color: #0066cc;
        cursor: pointer;
        text-decoration: none;
        font-family: monospace;
        font-size: 0.9em;
    }
    
    .timestamp-link:hover {
        text-decoration: underline;
    }
    
    /* SummerNote dark mode text styling */
    html[data-bs-theme="dark"] .note-editor {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    html[data-bs-theme="dark"] .note-editor .note-editable {
        background-color: rgba(255, 255, 255, 0.05);
        color: white;
    }
    
    html[data-bs-theme="dark"] .note-editor .note-placeholder {
        color: rgba(255, 255, 255, 0.5);
    }
    
    html[data-bs-theme="dark"] .note-editor .note-toolbar {
        background-color: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.2);
    }
    
    /* Note editor container */
    #note-editor-container {
        margin-top: 1rem;
    }
    
    /* Space status badges */
    .status-completed { background-color: #28a745; }
    .status-downloading { background-color: #17a2b8; }
    .status-pending { background-color: #ffc107; color: #000; }
    .status-failed { background-color: #dc3545; }
    
    /* Create clip button styling */
    #create-clip-btn {
        margin-left: auto;
    }
    
    /* Clip item styling */
    .clip-item {
        transition: all 0.2s ease;
    }
    
    .clip-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    /* Toast styling */
    .toast-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1050;
    }
    
    /* Star rating styling */
    .star-rating {
        font-size: 24px;
        cursor: pointer;
    }
    
    .star-rating i {
        color: #ddd;
        transition: color 0.2s;
    }
    
    .star-rating i:hover,
    .star-rating i.active {
        color: #ffc107;
    }
    
    .star-rating i.bi-star-fill {
        color: #ffc107;
    }
    
    /* Review item styling */
    .review-item {
        border-bottom: 1px solid var(--bs-gray-200);
        padding-bottom: 1rem;
        margin-bottom: 1rem;
    }
    
    .review-item:last-child {
        border-bottom: none;
        padding-bottom: 0;
        margin-bottom: 0;
    }
    
    .review-stars {
        color: #ffc107;
        font-size: 14px;
    }
    
    /* Timecode styling */
    .timecode-link {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-decoration: none !important;
        padding: 2px 4px;
        border-radius: 3px;
        transition: all 0.2s ease;
        display: inline-block;
    }
    
    .timecode-link:hover {
        background-color: #e3f2fd;
        color: #1976d2 !important;
        cursor: pointer;
        transform: scale(1.05);
    }
    
    .transcript-segment {
        border-left: 3px solid transparent;
        padding-left: 8px;
        transition: border-color 0.2s ease;
    }
    
    .transcript-segment:hover {
        border-left-color: #2196f3;
    }
    
    .timecode-link.active-timecode {
        background-color: #4caf50 !important;
        color: white !important;
    }
    
    /* Tag management styling */
    .tag-item {
        position: relative;
        display: inline-block;
    }
    
    .tag-delete-btn {
        z-index: 10;
        transition: opacity 0.2s ease;
        line-height: 1;
        padding: 2px !important;
        min-width: unset;
    }
    
    .tag-delete-btn:hover {
        background-color: #dc3545 !important;
        border-color: #dc3545 !important;
    }
    
    .tag-link {
        transition: padding-right 0.2s ease;
    }
    
    .tag-item:hover .tag-link {
        padding-right: 1.5rem !important;
    }
    
    /* Ensure proper spacing for tag container */
    #tags-container {
        min-height: 2rem;
    }
    
    /* Prevent text selection on tag items during interaction */
    .tag-item {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    /* Make sure tag links are still selectable for copying */
    .tag-link {
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
    }
    
    /* Plyr custom styling */
    .plyr {
        border-radius: 8px;
        font-family: inherit;
    }
    
    /* Improve time display visibility */
    .plyr__time {
        font-weight: 500;
        font-size: 14px;
        opacity: 1 !important;
    }
    
    .plyr__time + .plyr__time {
        opacity: 0.8;
    }
    
    /* Make volume control more compact on mobile */
    @media (max-width: 768px) {
        .plyr__volume {
            max-width: 60px;
        }
        
        .plyr__volume input[type=range] {
            width: 50px;
        }
    }
    
    .plyr--audio .plyr__control.plyr__tab-focus,
    .plyr--audio .plyr__control:hover,
    .plyr--audio .plyr__control[aria-expanded="true"] {
        background: var(--bs-primary);
        color: white;
    }
    
    .plyr--audio .plyr__progress__played {
        background: var(--bs-primary);
    }
    
    .plyr--audio .plyr__volume__input {
        color: var(--bs-primary);
    }
    
    .plyr--audio .plyr__controls {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 0 0 8px 8px;
    }
    
    /* Dark mode Plyr styling */
    html[data-bs-theme="dark"] .plyr {
        --plyr-color-main: var(--bs-primary);
        --plyr-video-background: #2b2b2b;
        --plyr-menu-background: #333;
        --plyr-menu-color: #eee;
    }
    
    html[data-bs-theme="dark"] .plyr--audio .plyr__controls {
        background: rgba(51, 51, 51, 0.95);
        border-radius: 0 0 8px 8px;
    }
    
    html[data-bs-theme="dark"] .plyr__control,
    html[data-bs-theme="dark"] .plyr__control[data-plyr] {
        color: #eee;
    }
    
    /* Improve time visibility in dark mode */
    html[data-bs-theme="dark"] .plyr__time {
        color: #fff !important;
        background: rgba(0, 0, 0, 0.5);
        padding: 2px 4px;
        border-radius: 3px;
    }
    
    /* Mobile dark mode adjustments */
    @media (max-width: 768px) {
        html[data-bs-theme="dark"] .plyr__time {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        html[data-bs-theme="dark"] .plyr__control[data-plyr="play"] {
            background: rgba(var(--bs-primary-rgb), 0.2);
        }
        
        html[data-bs-theme="dark"] .plyr__progress__container {
            background: rgba(255,255,255,0.1);
        }
    }
    
    html[data-bs-theme="dark"] .plyr--audio .plyr__progress__played,
    html[data-bs-theme="dark"] .plyr--audio .plyr__volume__input {
        color: var(--bs-primary);
    }
    
    /* Responsive Plyr controls */
    @media (max-width: 768px) {
        .plyr__control--overlaid {
            display: none;
        }
        
        /* Complete mobile redesign */
        .plyr--audio .plyr__controls {
            padding: 12px 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        /* Progress bar takes full width on its own row */
        .plyr__progress {
            width: 100%;
            order: -1;
            margin: 0 0 12px 0;
        }
        
        .plyr__progress input[type=range] {
            height: 44px;
            margin: -19px 0;
        }
        
        .plyr__progress__container {
            height: 6px;
            background: rgba(255,255,255,0.2);
        }
        
        /* Time displays on same row as progress */
        .plyr__time {
            font-size: 13px;
            font-weight: 600;
            min-width: 45px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 4px;
            margin: 0;
        }
        
        .plyr__time--current {
            order: -3;
            position: absolute;
            left: 8px;
            top: 12px;
        }
        
        .plyr__time--duration {
            order: -2;
            position: absolute;
            right: 8px;
            top: 12px;
        }
        
        /* Control buttons in bottom row */
        .plyr__control {
            padding: 10px;
            flex: 0 0 auto;
        }
        
        .plyr__control--overlaid {
            display: none !important;
        }
        
        /* Hide restart on mobile */
        .plyr__control[data-plyr="restart"] {
            display: none;
        }
        
        /* Make play button more prominent */
        .plyr__control[data-plyr="play"] {
            padding: 10px 16px;
            background: rgba(var(--bs-primary-rgb), 0.1);
            border-radius: 6px;
        }
        
        /* Hide fullscreen on audio */
        .plyr__control[data-plyr="fullscreen"] {
            display: none;
        }
        
        /* Adjust container for absolute positioned times */
        .plyr--audio .plyr__controls {
            position: relative;
            padding-top: 45px;
        }
    }
    
    /* Transcript section mobile improvements */
    @media (max-width: 576px) {
        .transcript-actions .btn-group {
            flex-wrap: wrap;
        }
        
        .transcript-actions .form-select {
            max-width: 120px !important;
        }
        
        #transcript-section .card-header {
            padding: 0.75rem;
        }
    }
    
    /* Skip controls styling */
    .audio-skip-controls {
        margin-top: 1rem;
    }
    
    .audio-skip-controls .btn {
        min-width: 100px;
        padding: 8px 16px;
        font-weight: 500;
    }
    
    @media (max-width: 576px) {
        .audio-skip-controls .btn {
            min-width: 60px;
            padding: 8px 12px;
        }
        
        .audio-skip-controls .btn i {
            font-size: 1.1rem;
        }
    }
    
    /* Integration with existing controls */
    .audio-controls {
        margin-top: 0.5rem;
    }
    
    /* Hide legacy controls that Plyr now provides */
    .plyr + .audio-controls .btn-group {
        display: none;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header">
                <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div class="d-flex gap-2 order-1 order-md-3">
                        <button id="transcribe-btn" class="btn btn-info btn-sm" data-service="transcription" data-original-class="btn-info" {% if space.transcripts %}data-has-transcript="true"{% endif %} {% if has_pending_transcript_job %}disabled{% endif %} data-bs-toggle="tooltip" data-bs-placement="top" title="{% if has_pending_transcript_job %}Transcription already in progress{% else %}Generate transcript from audio{% endif %}">
                            <i class="bi bi-mic"></i> <span class="d-none d-sm-inline">{% if has_pending_transcript_job %}Transcribing...{% else %}Transcribe{% endif %}</span>
                        </button>
                        <!-- Smart download button - will be populated by JavaScript -->
                        <div id="download-container">
                            <a href="/download/{{ space.space_id }}?attachment=1" class="btn btn-primary btn-sm text-white" data-bs-toggle="tooltip" data-bs-placement="top" title="Download file">
                                <i class="bi bi-download"></i> <span class="d-none d-sm-inline">Download</span>
                            </a>
                        </div>
                        <button id="generate-video-btn" class="btn btn-secondary btn-sm" data-service="video" data-original-class="btn-secondary" data-bs-toggle="tooltip" data-bs-placement="top" title="Generate MP4 video with waveform visualization">
                            <i class="bi bi-camera-video"></i> <span class="d-none d-sm-inline">Generate Video</span>
                        </button>
                        {% if can_edit_space %}
                        <button id="trim-btn" class="btn btn-warning btn-sm" data-bs-toggle="modal" data-bs-target="#trimModal" data-bs-toggle="tooltip" data-bs-placement="top" title="Trim audio file">
                            <i class="bi bi-scissors"></i> <span class="d-none d-sm-inline">Trim</span>
                        </button>
                        {% endif %}
                        <button id="share-btn" class="btn btn-success btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Share this space">
                            <i class="bi bi-share"></i> <span class="d-none d-sm-inline">Share</span>
                        </button>
                        <button id="favorite-btn" class="btn btn-sm {% if is_favorite %}btn-warning{% else %}btn-outline-warning{% endif %}" title="{% if is_favorite %}Remove from favorites{% else %}Add to favorites{% endif %}">
                            <i class="bi {% if is_favorite %}bi-star-fill{% else %}bi-star{% endif %}"></i>
                            <span class="d-none d-md-inline">Favorite</span>
                        </button>
                        <a href="{{ url_for('index') }}" class="btn btn-outline-primary btn-sm">
                            <i class="bi bi-house d-md-none"></i>
                            <span class="d-none d-md-inline">Back to Home</span>
                        </a>
                    </div>
                    <div class="d-flex align-items-center justify-content-start flex-grow-1 order-2 order-md-1">
                        <h4 id="space-title" class="mb-0 me-2">{{ space.title if space.title else "Space " + space.space_id }}</h4>
                        {% if can_edit_space %}
                        <button id="edit-title-btn" class="btn btn-link btn-sm p-0" title="Edit title">
                            <i class="bi bi-pencil"></i>
                        </button>
                        {% endif %}
                    </div>
                </div>
            </div>
            <div class="card-body">
                <div class="space-details mb-3">
                    <div class="d-flex align-items-center justify-content-between flex-wrap">
                        <div class="d-flex align-items-center gap-3">
                            <a href="{{ space.space_url }}" target="_blank" rel="noopener" class="text-decoration-none">
                                <code>{{ space.space_id }}</code> <i class="bi bi-box-arrow-up-right small"></i>
                            </a>
                            {% if space.status and space.status != 'completed' %}
                            <span class="badge {% if space.status == 'downloading' %}bg-info{% elif space.status == 'pending' %}bg-warning{% elif space.status == 'failed' %}bg-danger{% else %}bg-secondary{% endif %}">
                                {{ space.status|title }}
                            </span>
                            {% endif %}
                            {% if file_path and file_size %}
                            <span class="text-muted">{{ (file_size / 1048576)|round(1) }} MB</span>
                            {% endif %}
                            {% if space.created_at %}
                            <span class="text-muted">{{ space.created_at|relative_time }}</span>
                            {% endif %}
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            {% if reviews and reviews.total_reviews > 0 %}
                            <div class="rating-stars text-warning">
                                {% for i in range(1, 6) %}
                                    {% if i <= reviews.average_rating|int %}
                                        <i class="bi bi-star-fill"></i>
                                    {% elif i - 0.5 <= reviews.average_rating %}
                                        <i class="bi bi-star-half"></i>
                                    {% else %}
                                        <i class="bi bi-star"></i>
                                    {% endif %}
                                {% endfor %}
                                <span class="text-muted ms-1">({{ reviews.total_reviews }})</span>
                            </div>
                            {% endif %}
                        </div>
                    </div>
                </div>
                
                {# Metadata section #}
                <div class="metadata-section mb-3">
                    {% if not space.metadata %}
                    <div class="d-flex align-items-center gap-2">
                        <button id="fetch-metadata-btn" class="btn btn-info btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Fetch metadata from spacesdashboard.com">
                            <i class="bi bi-cloud-download"></i> Fetch Metadata
                        </button>
                    </div>
                    {% endif %}
                    
                    {# Display metadata if available #}
                    {% if space.metadata and (space.metadata.host_handle or space.metadata.speakers) %}
                    <div class="metadata-display mt-3">
                        <div class="d-flex align-items-center gap-3 flex-wrap">
                            {% if space.metadata.host_handle %}
                            <div class="d-flex align-items-center gap-2">
                                <strong>Host:</strong>
                                <a href="https://x.com/{{ space.metadata.host_handle[1:] }}" 
                                   target="_blank" 
                                   class="text-decoration-none"
                                   data-bs-toggle="tooltip" 
                                   data-bs-placement="top" 
                                   title="{{ space.metadata.host_handle }}">
                                    <img src="https://unavatar.io/twitter/{{ space.metadata.host_handle[1:] }}" 
                                         alt="{{ space.metadata.host_handle }}" 
                                         class="rounded-circle"
                                         style="width: 32px; height: 32px; border: 2px solid #511fb2;"
                                         onerror="this.src='https://ui-avatars.com/api/?name={{ space.metadata.host_handle[1:] }}&size=32&background=0D8ABC&color=fff'">
                                </a>
                            </div>
                            {% endif %}
                            
                            {% if space.metadata.speakers %}
                            <div class="d-flex align-items-center gap-2">
                                <strong>Speakers:</strong>
                                <div class="d-flex gap-1">
                                    {% for speaker in space.metadata.speakers %}
                                    <a href="https://x.com/{{ speaker[1:] }}" 
                                       target="_blank" 
                                       class="text-decoration-none"
                                       data-bs-toggle="tooltip" 
                                       data-bs-placement="top" 
                                       title="{{ speaker }}">
                                        <img src="https://unavatar.io/twitter/{{ speaker[1:] }}" 
                                             alt="{{ speaker }}" 
                                             class="rounded-circle"
                                             style="width: 32px; height: 32px; border: 2px solid #511fb2;"
                                             onerror="this.src='https://ui-avatars.com/api/?name={{ speaker[1:] }}&size=32&background=0D8ABC&color=fff'">
                                    </a>
                                    {% endfor %}
                                </div>
                            </div>
                            {% endif %}
                        </div>
                    </div>
                    {% endif %}
                </div>
                
                {# Check if file exists, regardless of status #}
                {% if file_path is defined and file_path %}
                <div class="audio-player mb-4">
                    <div class="card">
                        <div class="card-body">
                            <audio id="audio-player" class="w-100" preload="metadata">
                                <source src="/audio/{{ space.space_id }}.mp3" type="audio/mpeg">
                                Your browser does not support the audio element.
                            </audio>
                            
                            <!-- Skip controls outside Plyr for better mobile layout -->
                            <div class="audio-skip-controls mt-3 d-flex justify-content-center gap-2">
                                <button id="skip-backward" class="btn btn-outline-secondary" title="Skip backward 15 seconds">
                                    <i class="bi bi-skip-backward"></i> <span class="d-none d-sm-inline">15s</span>
                                </button>
                                <button id="skip-forward" class="btn btn-outline-secondary" title="Skip forward 30 seconds">
                                    <i class="bi bi-skip-forward"></i> <span class="d-none d-sm-inline">30s</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Clipping Controls -->
                    <div class="card mt-3">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h6 class="mb-0"><i class="bi bi-scissors"></i> Create Audio Clip</h6>
                            <button class="btn btn-link btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#clipping-controls">
                                <i class="bi bi-chevron-down"></i>
                            </button>
                        </div>
                        <div class="collapse" id="clipping-controls">
                            <div class="card-body">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <div class="d-flex align-items-center gap-2">
                                            <button id="mark-start" class="btn btn-sm btn-outline-success">
                                                <i class="bi bi-play-circle"></i> Mark Start
                                            </button>
                                            <span id="start-time-display" class="text-muted">--:--</span>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="d-flex align-items-center gap-2">
                                            <button id="mark-end" class="btn btn-sm btn-outline-danger">
                                                <i class="bi bi-stop-circle"></i> Mark End
                                            </button>
                                            <span id="end-time-display" class="text-muted">--:--</span>
                                        </div>
                                    </div>
                                    <div class="col-12">
                                        <div class="input-group">
                                            <input type="text" id="clip-title" class="form-control" placeholder="Enter clip title..." maxlength="255">
                                            <button id="create-clip" class="btn btn-primary" disabled>
                                                <i class="bi bi-scissors"></i> Create Clip
                                            </button>
                                        </div>
                                        <small class="text-muted">Duration: <span id="clip-duration">--:--</span></small>
                                    </div>
                                </div>
                                
                                {% if clips %}
                                <hr>
                                <h6>Existing Clips</h6>
                                <div class="list-group">
                                    {% for clip in clips %}
                                    <div class="list-group-item d-flex justify-content-between align-items-center">
                                        <div>
                                            <strong>{{ clip.clip_title }}</strong>
                                            <br>
                                            <small class="text-muted">
                                                {{ (clip.start_time // 60)|int }}:{{ '%02d'|format((clip.start_time % 60)|int) }} - 
                                                {{ (clip.end_time // 60)|int }}:{{ '%02d'|format((clip.end_time % 60)|int) }}
                                                ({{ (clip.duration // 60)|int }}:{{ '%02d'|format((clip.duration % 60)|int) }})
                                            </small>
                                        </div>
                                        <div class="btn-group btn-group-sm">
                                            <button class="btn btn-outline-success play-clip" data-clip-id="{{ clip.id }}" data-start="{{ clip.start_time }}" data-end="{{ clip.end_time }}" title="Play clip">
                                                <i class="bi bi-play-circle"></i>
                                            </button>
                                            <a href="/api/clips/{{ clip.id }}/download" class="btn btn-outline-primary" title="Download clip">
                                                <i class="bi bi-download"></i>
                                            </a>
                                            <button class="btn btn-outline-danger delete-clip" data-clip-id="{{ clip.id }}" data-clip-title="{{ clip.clip_title }}" title="Delete clip">
                                                <i class="bi bi-trash"></i>
                                            </button>
                                        </div>
                                    </div>
                                    {% endfor %}
                                </div>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Transcript Section -->
                <div id="transcript-section" class="mb-4" style="display: {% if space.transcripts %}block{% else %}none{% endif %};">
                    <h5>Transcript</h5>
                    <div class="card">
                        <div class="card-header bg-light">
                            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                <div class="d-flex align-items-center">
                                    {% if space.transcripts %}
                                    <select id="language-selector" class="form-select form-select-sm" style="width: auto;">
                                        {% for transcript in space.transcripts %}
                                        <option value="{{ transcript.id }}" data-language="{{ transcript.language }}">{{ transcript.language }}</option>
                                        {% endfor %}
                                    </select>
                                    {% endif %}
                                </div>
                                <div class="transcript-actions d-flex flex-wrap gap-1">
                                    <div class="btn-group" role="group">
                                        <select id="translate-target-lang" class="form-select form-select-sm" style="max-width: 150px;" data-bs-toggle="tooltip" data-bs-placement="top" title="Select target language">
                                            <option value="" selected>Translate to...</option>
                                            <option value="en">English</option>
                                            <option value="es">Spanish</option>
                                            <option value="fr">French</option>
                                            <option value="de">German</option>
                                            <option value="it">Italian</option>
                                            <option value="pt">Portuguese</option>
                                            <option value="bn">Bengali</option>
                                            <option value="zh">Chinese</option>
                                            <option value="ja">Japanese</option>
                                            <option value="ru">Russian</option>
                                        </select>
                                        <button id="translate-btn" class="btn btn-sm btn-outline-info" data-service="translation" data-original-class="btn-outline-info" data-bs-toggle="tooltip" data-bs-placement="top" title="Translate transcript">
                                            <i class="bi bi-translate"></i>
                                        </button>
                                    </div>
                                    <button id="summarize-btn" class="btn btn-sm btn-outline-warning" data-bs-toggle="tooltip" data-bs-placement="top" title="Generate AI summary">
                                        <i class="bi bi-lightbulb"></i>
                                    </button>
                                    <button id="transcript-copy-btn" class="btn btn-sm btn-outline-secondary" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy transcript to clipboard">
                                        <i class="bi bi-clipboard"></i>
                                    </button>
                                    <button id="transcript-download-btn" class="btn btn-sm btn-outline-primary" data-bs-toggle="tooltip" data-bs-placement="top" title="Download transcript as text file">
                                        <i class="bi bi-download"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="card-body">
                            <div id="transcript-content" class="transcript-text p-3" style="max-height: 400px; overflow-y: auto;">
                                {% if space.transcripts %}
                                <div class="transcript-loader text-center py-4">
                                    <div class="spinner-border text-primary" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <p class="mt-2">Loading transcript...</p>
                                </div>
                                {% else %}
                                <div class="text-center py-4">
                                    <p class="text-muted">No transcript available yet. Click the Transcribe button to generate one.</p>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
                {% elif space._file_missing or ((file_path is not defined or not file_path) and space.status == 'completed') %}
                <div class="alert alert-warning">
                    <h5>File Missing</h5>
                    <p>The audio file for this space is not available. It might have been deleted or moved.</p>
                    <form action="{{ url_for('submit_space') }}" method="POST">
                        <input type="hidden" name="space_url" value="{{ space.space_url }}">
                        <button type="submit" class="btn btn-primary">Download Again</button>
                    </form>
                </div>
                {% elif space.status != 'completed' %}
                <div id="download-status-container" class="alert alert-info">
                    <h5>Download Status</h5>
                    {% if space.status == 'downloading' or space.status == 'in_progress' %}
                    <p id="download-message">This space is currently being downloaded. You'll be able to listen to it once the download is complete.</p>
                    <p id="download-progress">Current progress: <span id="progress-percent">{{ space.download_cnt }}</span>%</p>
                    <div class="progress" style="height: 20px;">
                        <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                             role="progressbar" 
                             style="width: {{ space.download_cnt }}%;"
                             aria-valuenow="{{ space.download_cnt }}" 
                             aria-valuemin="0" 
                             aria-valuemax="100">
                            {{ space.download_cnt }}%
                        </div>
                    </div>
                    <div id="progress-size" class="mt-2">
                        {% if job and job.progress_in_size %}
                            Downloaded {{ job.progress_in_size|filesizeformat }} ({{ (job.progress_in_size / 1048576)|round(2) }} MB)
                        {% else %}
                            Waiting for download to start...
                        {% endif %}
                    </div>
                    {% elif space.status == 'pending' %}
                    <p id="download-message">This space is in the download queue. The download will start automatically.</p>
                    <div id="progress-container" class="d-none">
                        <p id="download-progress">Current progress: <span id="progress-percent">0</span>%</p>
                        <div class="progress" style="height: 20px;">
                            <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" 
                                 style="width: 0%;"
                                 aria-valuenow="0" 
                                 aria-valuemin="0" 
                                 aria-valuemax="100">
                                0%
                            </div>
                        </div>
                        <div id="progress-size" class="mt-2">Waiting for download to start...</div>
                    </div>
                    {% elif space.status == 'failed' %}
                    <p id="download-message">The download for this space failed. You can try downloading it again.</p>
                    <form action="{{ url_for('submit_space') }}" method="POST">
                        <input type="hidden" name="space_url" value="{{ space.space_url }}">
                        <button type="submit" class="btn btn-primary">Try Downloading Again</button>
                    </form>
                    {% else %}
                    <p id="download-message">This space has status: {{ space.status }}</p>
                    <form action="{{ url_for('submit_space') }}" method="POST">
                        <input type="hidden" name="space_url" value="{{ space.space_url }}">
                        <button type="submit" class="btn btn-primary">Try Downloading</button>
                    </form>
                    {% endif %}
                </div>
                {% else %}
                <div class="alert alert-warning">
                    <p>The audio file for this space is not available. It might have been deleted or moved.</p>
                    <a href="{{ url_for('submit_space') }}?space_url={{ space.space_url|urlencode }}" class="btn btn-primary">
                        Download Again
                    </a>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

{# Notes Section #}
<div class="row mt-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h4>Notes</h4>
                <button id="add-note-btn" class="btn btn-primary btn-sm">
                    <i class="bi bi-plus-circle"></i> Add Note
                </button>
            </div>
            <div class="card-body">
                <div id="notes-container">
                    {# Notes will be loaded here #}
                    <div class="text-center py-3">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading notes...</span>
                        </div>
                    </div>
                </div>
                
                {# Note editor (hidden by default) #}
                <div id="note-editor-container" style="display: none;">
                    <div class="mb-3">
                        <textarea id="note-editor" name="note-content"></textarea>
                    </div>
                    <div class="d-flex gap-2">
                        <button id="save-note-btn" class="btn btn-success">
                            <i class="bi bi-check-circle"></i> Save Note
                        </button>
                        <button id="cancel-note-btn" class="btn btn-secondary">
                            <i class="bi bi-x-circle"></i> Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Reviews Section -->
<div class="row mt-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#reviewsContent" aria-expanded="false" aria-controls="reviewsContent">
                <div class="d-flex align-items-center gap-2">
                    <h4 class="mb-0">Reviews</h4>
                    <i class="bi bi-chevron-down" id="reviews-toggle-icon"></i>
                </div>
                <div class="d-flex align-items-center gap-3">
                    <div class="d-flex align-items-center gap-2" id="header-review-summary">
                        <div class="text-warning" id="header-average-stars"></div>
                        <span class="text-muted" id="header-review-count"></span>
                    </div>
                    <button id="add-review-btn" class="btn btn-primary btn-sm" onclick="event.stopPropagation();">
                        <i class="bi bi-star"></i> Add Review
                    </button>
                </div>
            </div>
            <div class="collapse" id="reviewsContent">
                <div class="card-body">
                    {# Review summary #}
                    <div id="review-summary" class="mb-4">
                        <div class="d-flex align-items-center gap-3">
                            <div class="text-center">
                                <h2 class="mb-0" id="average-rating">0.0</h2>
                                <div id="average-stars" class="text-warning"></div>
                                <small class="text-muted"><span id="total-reviews">0</span> reviews</small>
                            </div>
                        </div>
                    </div>
                    
                    {# Reviews container #}
                    <div id="reviews-container">
                        <!-- Reviews will be loaded here -->
                    </div>
                
                    {# Review editor (hidden by default) #}
                    <div id="review-editor-container" style="display: none;">
                        <div class="card mb-3">
                            <div class="card-body">
                                <h5 id="review-editor-title">Write a Review</h5>
                                <div class="mb-3">
                                    <label class="form-label">Rating</label>
                                    <div id="star-rating" class="star-rating">
                                        <i class="bi bi-star" data-rating="1"></i>
                                        <i class="bi bi-star" data-rating="2"></i>
                                        <i class="bi bi-star" data-rating="3"></i>
                                        <i class="bi bi-star" data-rating="4"></i>
                                        <i class="bi bi-star" data-rating="5"></i>
                                    </div>
                                    <input type="hidden" id="review-rating" value="0">
                                </div>
                                <div class="mb-3">
                                    <label for="review-text" class="form-label">Review (optional)</label>
                                    <textarea id="review-text" class="form-control" rows="3" placeholder="Share your thoughts about this space..."></textarea>
                                </div>
                                <div class="d-flex gap-2">
                                    <button id="save-review-btn" class="btn btn-success">
                                        <i class="bi bi-check-circle"></i> Save Review
                                    </button>
                                    <button id="cancel-review-btn" class="btn btn-secondary">
                                        <i class="bi bi-x-circle"></i> Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Tags Section -->
<div class="row mt-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h4 class="mb-0">Tags</h4>
                {% if can_edit_space %}
                <button class="btn btn-sm btn-outline-primary" onclick="showAddTagModal()">
                    <i class="bi bi-plus"></i> Add Tag
                </button>
                {% endif %}
            </div>
            <div class="card-body">
                <div id="tags-container" class="d-flex flex-wrap gap-2">
                    {% if tags %}
                        {% for tag in tags %}
                        <div class="tag-item position-relative" data-tag-id="{{ tag.id }}" data-tag-name="{{ tag.tag_name }}">
                            <a href="{{ url_for('spaces_by_tag', tag_slug=tag.tag_slug) }}" 
                               class="badge bg-secondary text-decoration-none fs-6 px-3 py-2 tag-link">
                                <i class="bi bi-tag"></i> {{ tag.tag_name }}
                            </a>
                            {% if can_edit_space %}
                            <button class="btn btn-sm btn-danger tag-delete-btn position-absolute top-0 end-0 translate-middle rounded-circle p-1" 
                                    style="display: none; width: 20px; height: 20px; font-size: 10px;"
                                    onclick="confirmRemoveTag({{ tag.id }}, '{{ tag.tag_name }}', event)"
                                    title="Remove tag">
                                <i class="bi bi-x"></i>
                            </button>
                            {% endif %}
                        </div>
                        {% endfor %}
                    {% else %}
                        <p class="text-muted mb-0">No tags yet. {% if can_edit_space %}Click "Add Tag" to add some!{% endif %}</p>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>

{% if can_edit_space %}
<!-- Trim Modal -->
<div class="modal fade" id="trimModal" tabindex="-1" aria-labelledby="trimModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="trimModalLabel">Trim Audio</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle"></i> This will permanently modify the audio file. Make sure to keep a backup if needed.
                </div>
                
                <div class="mb-3">
                    <audio id="trim-audio-preview" class="w-100" preload="metadata">
                        <source src="/audio/{{ space.space_id }}.mp3" type="audio/mpeg">
                        Your browser does not support the audio element.
                    </audio>
                </div>
                
                <div class="row mb-3">
                    <div class="col-md-6">
                        <label class="form-label">Start Time</label>
                        <div class="input-group">
                            <input type="number" id="trim-start-min" class="form-control" min="0" value="0" placeholder="Min">
                            <span class="input-group-text">:</span>
                            <input type="number" id="trim-start-sec" class="form-control" min="0" max="59" value="0" placeholder="Sec">
                            <button id="set-current-start" class="btn btn-outline-secondary" type="button" title="Set to current time">
                                <i class="bi bi-cursor"></i>
                            </button>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">End Time</label>
                        <div class="input-group">
                            <input type="number" id="trim-end-min" class="form-control" min="0" value="0" placeholder="Min">
                            <span class="input-group-text">:</span>
                            <input type="number" id="trim-end-sec" class="form-control" min="0" max="59" value="0" placeholder="Sec">
                            <button id="set-current-end" class="btn btn-outline-secondary" type="button" title="Set to current time">
                                <i class="bi bi-cursor"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="alert alert-info">
                    <small>
                        <strong>Duration:</strong> <span id="trim-duration">--:--</span><br>
                        <strong>Range:</strong> <span id="trim-range">--:--</span>
                    </small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-warning" id="apply-trim-btn">
                    <i class="bi bi-scissors"></i> Apply Trim
                </button>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Share Modal -->
<div class="modal fade" id="shareModal" tabindex="-1" aria-labelledby="shareModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="shareModalLabel">Share Space</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="share-message" class="form-label">Message</label>
                    <textarea id="share-message" class="form-control" rows="3" readonly>Listen to "{{ space.title if space.title else 'Space ' + space.space_id }}" by {{ '@' + space.metadata.host_handle[1:] if space.metadata and space.metadata.host_handle and space.metadata.host_handle.startswith('@') else space.metadata.host_handle if space.metadata and space.metadata.host_handle else 'Unknown' }}

{{ request.url }}</textarea>
                </div>
                
                <div class="d-grid gap-2">
                    <button id="copy-share-btn" class="btn btn-primary">
                        <i class="bi bi-clipboard"></i> Copy to Clipboard
                    </button>
                    
                    <div class="row g-2">
                        <div class="col">
                            <a id="share-twitter" href="#" target="_blank" class="btn btn-outline-primary w-100">
                                <i class="bi bi-twitter"></i> Share on X
                            </a>
                        </div>
                        <div class="col">
                            <a id="share-facebook" href="#" target="_blank" class="btn btn-outline-primary w-100">
                                <i class="bi bi-facebook"></i> Facebook
                            </a>
                        </div>
                    </div>
                    
                    <div class="row g-2">
                        <div class="col">
                            <a id="share-whatsapp" href="#" target="_blank" class="btn btn-outline-success w-100">
                                <i class="bi bi-whatsapp"></i> WhatsApp
                            </a>
                        </div>
                        <div class="col">
                            <a id="share-telegram" href="#" target="_blank" class="btn btn-outline-info w-100">
                                <i class="bi bi-telegram"></i> Telegram
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add Tag Modal -->
{% if can_edit_space %}
<div class="modal fade" id="addTagModal" tabindex="-1" aria-labelledby="addTagModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addTagModalLabel">Add Tag</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="addTagForm">
                    <div class="mb-3">
                        <label for="tag-name" class="form-label">Tag Name</label>
                        <input type="text" class="form-control" id="tag-name" name="tag_name" 
                               placeholder="Enter tag name..." maxlength="50" required>
                        <div class="form-text">
                            Tags help categorize and make spaces easier to find. Use descriptive keywords.
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="addTag()">Add Tag</button>
            </div>
        </div>
    </div>
</div>

<!-- Confirm Remove Tag Modal -->
<div class="modal fade" id="confirmRemoveTagModal" tabindex="-1" aria-labelledby="confirmRemoveTagModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="confirmRemoveTagModalLabel">Remove Tag</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to remove the tag "<span id="tag-to-remove-name"></span>" from this space?</p>
                <p class="text-muted small">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="removeTag()">Remove Tag</button>
            </div>
        </div>
    </div>
</div>
{% endif %}

{% endblock %}


{% block scripts %}
<script>
    // Language code to name mapping - define globally for template access
    const languageNames = {
        'en': 'English',
        'es': 'Spanish', 
        'fr': 'French',
        'de': 'German',
        'it': 'Italian',
        'pt': 'Portuguese',
        'hi': 'Hindi',
        'bn': 'Bengali',
        'ar': 'Arabic',
        'zh': 'Chinese',
        'ja': 'Japanese',
        'ko': 'Korean',
        'ru': 'Russian',
        'nl': 'Dutch',
        'pl': 'Polish',
        'tr': 'Turkish',
        'vi': 'Vietnamese',
        'id': 'Indonesian',
        'th': 'Thai',
        'sv': 'Swedish',
        'da': 'Danish',
        'no': 'Norwegian',
        'fi': 'Finnish'
    };
    
    // Function to get language name from code
    function getLanguageName(code) {
        // Handle language codes with country (e.g., 'en-US' -> 'en')
        const langCode = code.split('-')[0].toLowerCase();
        return languageNames[langCode] || code;
    }
    
    // Cookie functions
    function setCookie(name, value, days) {
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = name + '=' + value + ';expires=' + expires.toUTCString() + ';path=/';
    }
    
    function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }
    
    // Function to get or create cookie ID (make it global)
    window.getCookieId = function() {
        let cookieId = getCookie('xspace_user_id');
        if (!cookieId) {
            cookieId = 'user_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
            setCookie('xspace_user_id', cookieId, 365);
        }
        return cookieId;
    };
    
    // Global function to seek audio player to specific time
    function seekToTime(seconds) {
        if (window.mainPlayer) {
            const mainPlayer = window.mainPlayer;
            try {
                // Remove previous highlights
                document.querySelectorAll('.timecode-link').forEach(link => {
                    link.style.backgroundColor = '';
                    link.classList.remove('active-timecode');
                });
                
                // Highlight the clicked timecode
                if (event && event.target) {
                    event.target.style.backgroundColor = '#4caf50';
                    event.target.style.color = 'white';
                    event.target.classList.add('active-timecode');
                }
                
                // Seek to the time (adjusted for silence offset)
                const adjustedTime = Math.max(0, seconds - (window.silenceOffset || 0));
                window.mainPlayer.currentTime = adjustedTime;
                
                // Auto-play if paused
                if (window.mainPlayer.paused) {
                    window.mainPlayer.play().catch(e => {
                        console.log('Auto-play prevented by browser:', e);
                        // Just seek without playing if auto-play is blocked
                    });
                }
                
                // Scroll the audio player into view if not visible
                const playerElement = document.getElementById('audio-player');
                if (playerElement) {
                    playerElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
            } catch (error) {
                console.error('Error seeking to time:', error);
            }
        } else {
            console.error('Audio player not found');
        }
    }
    
    // Global function to update current playing position highlight
    function updateCurrentSegmentHighlight() {
        if (!window.mainPlayer) return;
        
        const currentTime = window.mainPlayer.currentTime;
        const timecodeLinks = document.querySelectorAll('.timecode-link');
        let activeLink = null;
        
        // Find the current segment
        timecodeLinks.forEach(link => {
            const linkTime = parseFloat(link.getAttribute('data-time'));
            if (linkTime <= currentTime) {
                activeLink = link;
            }
        });
        
        // Update highlighting
        timecodeLinks.forEach(link => {
            if (link === activeLink && !link.classList.contains('active-timecode')) {
                link.style.backgroundColor = '#2196f3';
                link.style.color = 'white';
            } else if (link !== activeLink && !link.classList.contains('active-timecode')) {
                link.style.backgroundColor = '';
                link.style.color = '';
            }
        });
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        const audioPlayer = document.getElementById('audio-player');
        window.spaceId = '{{ space.space_id }}';
        window.spaceStatus = '{{ space.status|default("") }}';
        const minPlayDuration = {% if tracking_config and tracking_config.min_play_duration %}{{ tracking_config.min_play_duration }}{% else %}30{% endif %};
        
        // Initialize silence offset for timecode correction
        window.silenceOffset = 0;
        fetch(`/api/spaces/${spaceId}/silence-offset`)
            .then(response => response.json())
            .then(data => {
                if (data.silence_offset) {
                    window.silenceOffset = data.silence_offset;
                    console.log(`Loaded silence offset: ${window.silenceOffset} seconds`);
                }
            })
            .catch(error => {
                console.warn('Could not load silence offset:', error);
            });
        
        // Initialize Bootstrap tooltips
        const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
        const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
        
        // Audio player setup (wait for Plyr to be ready)
        function setupAudioTracking() {
            if (mainPlayer) {
                // Track play count with duration
                let playStartTime = null;
                let totalPlayDuration = 0;
                let hasTrackedPlay = false;
                
                // Function to update play duration and check if we should track
                function updatePlayDuration() {
                    if (playStartTime) {
                        const sessionDuration = (Date.now() - playStartTime) / 1000;
                        totalPlayDuration += sessionDuration;
                        playStartTime = Date.now(); // Reset for continuous tracking
                        
                        console.log(`Play duration updated. Session: ${sessionDuration}s, Total: ${totalPlayDuration}s, Min required: ${minPlayDuration}s, Already tracked: ${hasTrackedPlay}`);
                        
                        // Track play if duration is >= configured minimum and not already tracked
                        if (totalPlayDuration >= minPlayDuration && !hasTrackedPlay) {
                            hasTrackedPlay = true;
                            console.log('Triggering play tracking...');
                            fetch(`/api/track_play/${spaceId}`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    duration: Math.round(totalPlayDuration)
                                })
                            }).then(response => response.json())
                            .then(data => {
                            console.log('Play tracking response:', data);
                            if (!data.counted) {
                                console.log('Play not counted:', data.reason);
                            } else {
                                console.log('Play successfully tracked');
                            }
                            }).catch(error => {
                                console.error('Error tracking play:', error);
                            });
                    }
                }
            }
            
                mainPlayer.on('play', function() {
                    playStartTime = Date.now();
                    console.log('Audio started playing at:', new Date(playStartTime));
                });
                
                mainPlayer.on('pause', function() {
                    if (playStartTime) {
                        const sessionDuration = (Date.now() - playStartTime) / 1000;
                        totalPlayDuration += sessionDuration;
                        playStartTime = null;
                        
                        console.log(`Audio paused. Session duration: ${sessionDuration}s, Total duration: ${totalPlayDuration}s`);
                        updatePlayDuration();
                    }
                });
                
                // Check play duration periodically while playing
                let playCheckInterval;
                mainPlayer.on('play', function() {
                    playCheckInterval = setInterval(updatePlayDuration, 5000); // Check every 5 seconds
                });
                
                mainPlayer.on('pause', function() {
                    if (playCheckInterval) {
                        clearInterval(playCheckInterval);
                    }
                });
                
                // Reset tracking when audio ends
                mainPlayer.on('ended', function() {
                    if (playCheckInterval) {
                        clearInterval(playCheckInterval);
                    }
                    
                    if (playStartTime) {
                        const sessionDuration = (Date.now() - playStartTime) / 1000;
                        totalPlayDuration += sessionDuration;
                        playStartTime = null;
                    }
                    
                    console.log(`Audio ended. Total duration: ${totalPlayDuration}s, Min required: ${minPlayDuration}s, Already tracked: ${hasTrackedPlay}`);
                    
                    // Track play if duration is >= configured minimum and not already tracked
                    if (totalPlayDuration >= minPlayDuration && !hasTrackedPlay) {
                        hasTrackedPlay = true;
                        console.log('Triggering play tracking on ended...');
                        fetch(`/api/track_play/${spaceId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                duration: Math.round(totalPlayDuration)
                            })
                            }).then(response => response.json())
                            .then(data => {
                            console.log('Play tracking response (ended):', data);
                            if (!data.counted) {
                                console.log('Play not counted:', data.reason);
                            } else {
                                console.log('Play successfully tracked on ended');
                            }
                            }).catch(error => {
                                console.error('Error tracking play:', error);
                            });
                    }
                    
                    // Reset for next play
                    hasTrackedPlay = false;
                    totalPlayDuration = 0;
                });
                
                // Setup timecode highlighting
                mainPlayer.on('timeupdate', updateCurrentSegmentHighlight);
            
                // Remember playback position
                const storageKey = 'xspace_position_' + spaceId;
                
                // Load saved position
                const savedPosition = localStorage.getItem(storageKey);
                if (savedPosition) {
                    mainPlayer.currentTime = parseFloat(savedPosition);
                }
                
                // Save position every 5 seconds
                setInterval(() => {
                    if (!mainPlayer.paused) {
                        localStorage.setItem(storageKey, mainPlayer.currentTime.toString());
                    }
                }, 5000);
                
                // Save position on pause/stop
                mainPlayer.on('pause', () => {
                    localStorage.setItem(storageKey, mainPlayer.currentTime.toString());
                });
                
            }
        }
        
        // Wait for Plyr to be ready before setting up tracking
        function waitForPlyr() {
            if (window.mainPlayer) {
                setupAudioTracking();
            } else {
                setTimeout(waitForPlyr, 100);
            }
        }
        waitForPlyr();
            
        // Skip forward/backward buttons
        const skipForward = document.getElementById('skip-forward');
        const skipBackward = document.getElementById('skip-backward');
        
        if (skipForward) {
            skipForward.addEventListener('click', function() {
                if (window.mainPlayer) {
                    window.mainPlayer.currentTime = Math.min(window.mainPlayer.currentTime + 30, window.mainPlayer.duration);
                }
            });
        }
        
        if (skipBackward) {
            skipBackward.addEventListener('click', function() {
                if (window.mainPlayer) {
                    window.mainPlayer.currentTime = Math.max(window.mainPlayer.currentTime - 15, 0);
                }
            });
        }
            
        function updateTimeDisplay() {
            // Plyr handles time display internally, so this function is optional now
            // Keep it for backwards compatibility if there are custom time displays
        }
        
        function updatePlayerInfo() {
            // Called when Plyr player is ready
            console.log('Plyr player is ready');
        }
            
        // Keyboard shortcuts (Plyr has built-in keyboard support, but we can add custom ones)
        document.addEventListener('keydown', function(e) {
            if (window.mainPlayer) {
                const mainPlayer = window.mainPlayer;
                const audioPlayerElement = document.getElementById('audio-player');
                if (audioPlayerElement) {
                    const rect = audioPlayerElement.getBoundingClientRect();
                    const isInView = (rect.top >= 0 && rect.bottom <= window.innerHeight);
                    
                    if (isInView) {
                        // Right arrow - skip forward 30s
                        if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            mainPlayer.currentTime = Math.min(mainPlayer.currentTime + 30, mainPlayer.duration);
                        }
                        
                        // Left arrow - skip backward 15s
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            mainPlayer.currentTime = Math.max(mainPlayer.currentTime - 15, 0);
                        }
                    }
                }
            }
        });
            
            // Clipping functionality
            setupClippingControls();
        });
        
        // Setup clipping controls
        function setupClippingControls() {
            const markStartBtn = document.getElementById('mark-start');
            const markEndBtn = document.getElementById('mark-end');
            const createClipBtn = document.getElementById('create-clip');
            const clipTitleInput = document.getElementById('clip-title');
            const startTimeDisplay = document.getElementById('start-time-display');
            const endTimeDisplay = document.getElementById('end-time-display');
            const clipDurationDisplay = document.getElementById('clip-duration');
            
            let clipStartTime = null;
            let clipEndTime = null;
            
            // Format time for display
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Update clip duration display
            function updateClipDuration() {
                if (clipStartTime !== null && clipEndTime !== null && clipEndTime > clipStartTime) {
                    const duration = clipEndTime - clipStartTime;
                    clipDurationDisplay.textContent = formatTime(duration);
                    
                    // Enable create button if we have a title
                    createClipBtn.disabled = !clipTitleInput.value.trim() || duration > 300;
                    
                    if (duration > 300) {
                        clipDurationDisplay.innerHTML = formatTime(duration) + ' <span class="text-danger">(max 5 min)</span>';
                    }
                } else {
                    clipDurationDisplay.textContent = '--:--';
                    createClipBtn.disabled = true;
                }
            }
            
            // Mark start time
            if (markStartBtn) {
                markStartBtn.addEventListener('click', function() {
                    if (audioPlayer && !isNaN(audioPlayer.currentTime)) {
                        clipStartTime = audioPlayer.currentTime;
                        startTimeDisplay.textContent = formatTime(clipStartTime);
                        updateClipDuration();
                    }
                });
            }
            
            // Mark end time
            if (markEndBtn) {
                markEndBtn.addEventListener('click', function() {
                    if (audioPlayer && !isNaN(audioPlayer.currentTime)) {
                        clipEndTime = audioPlayer.currentTime;
                        endTimeDisplay.textContent = formatTime(clipEndTime);
                        updateClipDuration();
                    }
                });
            }
            
            // Update button state when title changes
            if (clipTitleInput) {
                clipTitleInput.addEventListener('input', updateClipDuration);
            }
            
            // Create clip
            if (createClipBtn) {
                createClipBtn.addEventListener('click', function() {
                    const title = clipTitleInput.value.trim();
                    
                    if (!title) {
                        showToast('Please enter a clip title', 'warning');
                        return;
                    }
                    
                    if (clipStartTime === null || clipEndTime === null) {
                        showToast('Please mark both start and end times', 'warning');
                        return;
                    }
                    
                    if (clipEndTime <= clipStartTime) {
                        showToast('End time must be after start time', 'warning');
                        return;
                    }
                    
                    const duration = clipEndTime - clipStartTime;
                    if (duration > 300) {
                        showToast('Clip duration cannot exceed 5 minutes', 'warning');
                        return;
                    }
                    
                    // Disable button and show loading
                    createClipBtn.disabled = true;
                    createClipBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Creating...';
                    
                    // Create the clip
                    fetch(`/api/spaces/${spaceId}/clips`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            title: title,
                            start_time: clipStartTime,
                            end_time: clipEndTime
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showToast('Clip created successfully!', 'success');
                            
                            // Reset form
                            clipTitleInput.value = '';
                            clipStartTime = null;
                            clipEndTime = null;
                            startTimeDisplay.textContent = '--:--';
                            endTimeDisplay.textContent = '--:--';
                            clipDurationDisplay.textContent = '--:--';
                            
                            // Reload page to show new clip
                            setTimeout(() => {
                                window.location.reload();
                            }, 1500);
                        } else {
                            showToast('Failed to create clip: ' + (data.error || 'Unknown error'), 'danger');
                        }
                    })
                    .catch(error => {
                        console.error('Error creating clip:', error);
                        showToast('Error creating clip', 'danger');
                    })
                    .finally(() => {
                        createClipBtn.disabled = false;
                        createClipBtn.innerHTML = '<i class="bi bi-scissors"></i> Create Clip';
                        updateClipDuration();
                    });
                });
            }
            
            // Play clip buttons
            document.querySelectorAll('.play-clip').forEach(btn => {
                btn.addEventListener('click', function() {
                    const startTime = parseFloat(this.getAttribute('data-start'));
                    const endTime = parseFloat(this.getAttribute('data-end'));
                    
                    if (audioPlayer) {
                        // Set current time to start
                        audioPlayer.currentTime = startTime;
                        audioPlayer.play();
                        
                        // Stop at end time
                        const checkEnd = setInterval(() => {
                            if (audioPlayer.currentTime >= endTime || audioPlayer.paused) {
                                audioPlayer.pause();
                                clearInterval(checkEnd);
                            }
                        }, 100);
                    }
                });
            });
            
            // Delete clip buttons
            document.querySelectorAll('.delete-clip').forEach(btn => {
                btn.addEventListener('click', function() {
                    const clipId = this.getAttribute('data-clip-id');
                    const clipTitle = this.getAttribute('data-clip-title');
                    
                    if (confirm(`Are you sure you want to delete the clip "${clipTitle}"?`)) {
                        // Disable button and show loading
                        this.disabled = true;
                        this.innerHTML = '<i class="bi bi-hourglass-split"></i>';
                        
                        fetch(`/api/clips/${clipId}`, {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/json',
                            }
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                showToast('Clip deleted successfully', 'success');
                                
                                // Remove the clip from the list
                                const clipElement = this.closest('.list-group-item');
                                clipElement.style.transition = 'opacity 0.3s';
                                clipElement.style.opacity = '0';
                                setTimeout(() => {
                                    clipElement.remove();
                                    
                                    // If no clips left, reload page to update UI
                                    if (document.querySelectorAll('.list-group-item').length === 0) {
                                        window.location.reload();
                                    }
                                }, 300);
                            } else {
                                showToast('Failed to delete clip: ' + (data.error || 'Unknown error'), 'danger');
                                // Re-enable button
                                this.disabled = false;
                                this.innerHTML = '<i class="bi bi-trash"></i>';
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting clip:', error);
                            showToast('Error deleting clip', 'danger');
                            // Re-enable button
                            this.disabled = false;
                            this.innerHTML = '<i class="bi bi-trash"></i>';
                        });
                    }
                });
            });
        }
        
        // Transcription functionality
        const transcribeBtn = document.getElementById('transcribe-btn');
        const transcriptSection = document.getElementById('transcript-section');
        const transcriptContent = document.getElementById('transcript-content');
        
        // Summary functionality
        const summarizeBtn = document.getElementById('summarize-btn');
        
        // Store the full transcript text in JavaScript variable (more reliable than HTML attributes)
        let fullTranscriptText = '';
        
        // Simple toast notification function
        function showToast(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 350px;';
            toast.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            
            // Add to body
            document.body.appendChild(toast);
            
            // Auto-remove after 4 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 4000);
        }
        
        if (transcribeBtn) {
            // Check if transcript already exists and disable button if so
            if (transcribeBtn.getAttribute('data-has-transcript') === 'true') {
                transcribeBtn.disabled = true;
                transcribeBtn.innerHTML = '<i class="bi bi-check-circle"></i> Transcribed';
                transcribeBtn.setAttribute('title', 'Transcript already exists');
                // Update tooltip if it exists
                const tooltip = bootstrap.Tooltip.getInstance(transcribeBtn);
                if (tooltip) {
                    tooltip.setContent({ '.tooltip-inner': 'Transcript already exists' });
                }
            }
            
            transcribeBtn.addEventListener('click', function() {
                // Disable button during transcription
                transcribeBtn.disabled = true;
                transcribeBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Transcribing...';
                
                // Request permissions for notifications
                if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                    Notification.requestPermission();
                }
                
                // Make API request to start transcription directly with English defaults
                fetch(`/api/transcribe/${spaceId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        language: 'en',
                        model: 'base',
                        detect_language: false,
                        translate_to: null,
                        overwrite: true
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        // Show error
                        alert('Transcription failed: ' + data.error);
                        // Reset button
                        transcribeBtn.disabled = false;
                        transcribeBtn.innerHTML = '<i class="bi bi-mic"></i> Transcribe';
                        return;
                    }
                    
                    if (data.from_database && data.transcript_id) {
                        // Transcript already exists in database - show it immediately
                        console.log('Using existing transcript from database (transcript_id:', data.transcript_id, ')');
                        transcribeBtn.disabled = true;
                        transcribeBtn.innerHTML = '<i class="bi bi-check-circle"></i> Transcribed';
                        transcribeBtn.setAttribute('data-has-transcript', 'true');
                        
                        // Load and show the transcript
                        loadTranscript(data.transcript_id);
                        transcriptSection.style.display = 'block';
                        
                        // Show success notification for database retrieval
                        if ('Notification' in window && Notification.permission === 'granted') {
                            new Notification('Transcript Loaded', {
                                body: 'Existing transcript loaded from database',
                                icon: '/static/favicon.ico'
                            });
                        }
                        
                        // Show toast/alert for immediate feedback
                        showToast('Transcript loaded from database', 'success');
                        
                    } else if (data.job_id) {
                        // Start polling for progress - new transcription
                        console.log('Starting new transcription with job ID:', data.job_id);
                        const jobId = data.job_id;
                        pollTranscriptionProgress(jobId);
                        
                    } else if (data.transcript_id) {
                        // Fallback: transcription completed immediately (shouldn't happen with new flow)
                        transcribeBtn.disabled = true;
                        transcribeBtn.innerHTML = '<i class="bi bi-check-circle"></i> Transcribed';
                        transcribeBtn.setAttribute('data-has-transcript', 'true');
                        
                        // Load and show the transcript
                        loadTranscript(data.transcript_id);
                        transcriptSection.style.display = 'block';
                        
                        // Show success notification
                        if ('Notification' in window && Notification.permission === 'granted') {
                            new Notification('Transcription Complete', {
                                body: 'The transcript is ready to view.',
                                icon: '/static/favicon.ico'
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while starting transcription.');
                    // Reset button only if no transcript exists
                    if (transcribeBtn.getAttribute('data-has-transcript') !== 'true') {
                        transcribeBtn.disabled = false;
                        transcribeBtn.innerHTML = '<i class="bi bi-mic"></i> Transcribe';
                    } else {
                        transcribeBtn.disabled = true;
                        transcribeBtn.innerHTML = '<i class="bi bi-check-circle"></i> Transcribed';
                    }
                });
            });
        }
        
        // Function to format transcript with clickable timecodes
        function formatTranscriptWithTimecodes(text) {
            // Check if transcript has timecodes in format [HH:MM:SS]
            const timecodeRegex = /\[(\d{2}):(\d{2}):(\d{2})\]\s*(.*?)(?=\[|$)/gs;
            const hasTimecodes = timecodeRegex.test(text);
            
            if (!hasTimecodes) {
                // No timecodes found, format as paragraphs
                return text.split('\n').filter(p => p.trim()).map(p => `<p>${p}</p>`).join('');
            }
            
            // Reset regex after test
            timecodeRegex.lastIndex = 0;
            
            // Format with clickable timecodes
            let formattedHtml = '';
            let match;
            
            while ((match = timecodeRegex.exec(text)) !== null) {
                const [fullMatch, hours, minutes, seconds, content] = match;
                const totalSeconds = parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(seconds);
                
                formattedHtml += `
                    <div class="transcript-segment mb-2">
                        <a href="#" class="timecode-link text-primary" data-time="${totalSeconds}" 
                           onclick="seekToTime(${totalSeconds}); return false;">
                            [${hours}:${minutes}:${seconds}]
                        </a>
                        <span class="transcript-text ms-2">${content.trim()}</span>
                    </div>
                `;
            }
            
            return formattedHtml || '<p>' + text + '</p>';
        }
        
        
        // Function to load transcript content
        function loadTranscript(transcriptId) {
            console.log('Loading transcript:', transcriptId);
            fetch(`/api/transcript/${transcriptId}`)
                .then(response => {
                    console.log('Transcript response:', response);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Transcript data:', data);
                    if (data.error) {
                        transcriptContent.innerHTML = `
                            <div class="alert alert-danger">
                                ${data.error}
                            </div>
                        `;
                    } else {
                        // Store the full transcript text in JavaScript variable (safer than HTML attributes)
                        fullTranscriptText = data.transcript;
                        
                        // Format text for display with timecode support
                        const formattedText = formatTranscriptWithTimecodes(data.transcript);
                        
                        transcriptContent.innerHTML = `
                            <div class="transcript-text">
                                ${formattedText}
                            </div>
                        `;
                        
                        // Don't clear the translation selection - keep it for reference
                        
                        // Store the source language code
                        transcriptContent.setAttribute('data-source-lang', data.language ? data.language.split('-')[0] : 'en');
                    }
                })
                .catch(error => {
                    console.error('Error loading transcript:', error);
                    transcriptContent.innerHTML = `
                        <div class="alert alert-danger">
                            Error loading transcript: ${error.message}
                        </div>
                    `;
                });
        }
        
        // Function to check translation service availability
        function checkTranslationService() {
            return new Promise((resolve, reject) => {
                // Simple health check request to the translation API
                fetch('/api/translate/info', { 
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        reject(new Error('Translation service unavailable'));
                        return;
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.available) {
                        resolve(data);
                    } else {
                        reject(new Error('Translation service configuration issue'));
                    }
                })
                .catch(error => {
                    reject(error);
                });
            });
        }
        
        // Function to reset transcript view to original content
        function resetTranscriptView() {
            const originalText = fullTranscriptText || transcriptContent.getAttribute('data-original-text') || '';
            const formattedOriginalText = formatTranscriptWithTimecodes(originalText);
            transcriptContent.innerHTML = `
                <div class="transcript-text">
                    ${formattedOriginalText}
                </div>
            `;
            // Reset the translation dropdown when showing original
            document.getElementById('translate-target-lang').value = '';
        }
        
        // Function to translate transcript content
        function pollTranslationJob(jobId, spaceId, targetLang) {
            const transcriptContent = document.querySelector('#transcript-content');
            let pollCount = 0;
            const maxPolls = 60; // 5 minutes max (5 second intervals)
            
            function pollStatus() {
                pollCount++;
                
                // Update progress message
                transcriptContent.innerHTML = `
                    <div class="alert alert-info">
                        <div class="d-flex align-items-center">
                            <div class="spinner-border text-primary me-3" role="status" aria-hidden="true" style="width: 1.5rem; height: 1.5rem;"></div>
                            <div>
                                <strong>Processing translation...</strong><br>
                                <small>Translating transcript to ${getLanguageName(targetLang)}. Please wait... (${pollCount}/${maxPolls})</small>
                            </div>
                        </div>
                    </div>
                `;
                
                // Check if we've exceeded max polls
                if (pollCount >= maxPolls) {
                    transcriptContent.innerHTML = `
                        <div class="alert alert-warning">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            Translation is taking longer than expected. Please check back later or refresh the page.
                        </div>
                    `;
                    return;
                }
                
                // Poll for updated transcript
                fetch(`/api/transcript/${spaceId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.language && data.language.startsWith(targetLang.split('-')[0])) {
                            // Translation completed! Display it
                            const formattedText = formatTranscriptWithTimecodes(data.transcript);
                            
                            transcriptContent.innerHTML = `
                                <div class="transcript-text translated" data-target-lang="${data.language}">
                                    <div class="alert alert-success mb-3">
                                        <small>
                                            <i class="bi bi-check-circle"></i> 
                                            Translation completed! This transcript has been translated to ${getLanguageName(data.language)}.
                                            <a href="#" id="show-original">Show original</a>
                                        </small>
                                    </div>
                                    ${formattedText}
                                </div>
                            `;
                            
                            // Store original text for show/hide functionality
                            transcriptContent.setAttribute('data-original-text', originalTranscriptText);
                            transcriptContent.setAttribute('data-translation-lang', data.language);
                            
                            // Add event listener to "Show original" link
                            document.getElementById('show-original').addEventListener('click', function(e) {
                                e.preventDefault();
                                const originalText = originalTranscriptText;
                                const formattedOriginalText = formatTranscriptWithTimecodes(originalText);
                                transcriptContent.innerHTML = `
                                    <div class="transcript-text">
                                        <div class="alert alert-info mb-3">
                                            <small>
                                                <i class="bi bi-info-circle"></i> 
                                                Showing original transcript.
                                                <a href="#" id="show-translated">Show translation</a>
                                            </small>
                                        </div>
                                        ${formattedOriginalText}
                                    </div>
                                `;
                                
                                // Add event listener to go back to translation
                                document.getElementById('show-translated').addEventListener('click', function(e) {
                                    e.preventDefault();
                                    const translatedText = transcriptContent.getAttribute('data-translation-text');
                                    const formattedTranslatedText = formatTranscriptWithTimecodes(translatedText);
                                    transcriptContent.innerHTML = `
                                        <div class="transcript-text translated" data-target-lang="${data.language}">
                                            <div class="alert alert-success mb-3">
                                                <small>
                                                    <i class="bi bi-check-circle"></i> 
                                                    Translation completed! This transcript has been translated to ${getLanguageName(data.language)}.
                                                    <a href="#" id="show-original">Show original</a>
                                                </small>
                                            </div>
                                            ${formattedTranslatedText}
                                        </div>
                                    `;
                                });
                            });
                            
                            // Store translated text for later use
                            transcriptContent.setAttribute('data-translation-text', data.transcript);
                            
                        } else {
                            // Translation not complete yet, continue polling
                            setTimeout(pollStatus, 5000); // Poll every 5 seconds
                        }
                    })
                    .catch(error => {
                        console.error('Error polling translation status:', error);
                        setTimeout(pollStatus, 5000); // Continue polling on error
                    });
            }
            
            // Start polling
            setTimeout(pollStatus, 2000); // Wait 2 seconds before first poll
        }
        
        function translateTranscript(sourceText, sourceLang, targetLang) {
            // Show loading indicator
            transcriptContent.innerHTML = `
                <div class="transcript-loader text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Translating...</span>
                    </div>
                    <p class="mt-2">Translating to ${getLanguageName(targetLang)}...</p>
                </div>
            `;
            
            // Extract timecodes and text separately to preserve timecodes during translation
            const timecodeRegex = /\[(\d{2}):(\d{2}):(\d{2})\]\s*(.*?)(?=\[|$)/gs;
            const segments = [];
            let textToTranslate = '';
            let match;
            
            // Check if source text has timecodes
            const hasTimecodes = timecodeRegex.test(sourceText);
            timecodeRegex.lastIndex = 0; // Reset regex
            
            if (hasTimecodes) {
                // Extract segments with timecodes
                while ((match = timecodeRegex.exec(sourceText)) !== null) {
                    const [fullMatch, hours, minutes, seconds, content] = match;
                    const timecode = `[${hours}:${minutes}:${seconds}]`;
                    const text = content.trim();
                    
                    segments.push({
                        timecode: timecode,
                        text: text,
                        fullTimecode: `${timecode} `
                    });
                    
                    // Build text for translation preserving original timecodes
                    if (text) {
                        textToTranslate += `${timecode} ${text}\n`;
                    }
                }
            } else {
                // No timecodes, translate as-is
                textToTranslate = sourceText;
            }
            
            // First check if translation service is available
            checkTranslationService()
                .catch(error => {
                    // Service check failed, show a helpful message
                    transcriptContent.innerHTML = `
                        <div class="alert alert-danger">
                            <div><i class="bi bi-exclamation-triangle-fill me-2"></i> Translation service is not available</div>
                            <p class="mt-2 mb-0">
                                <strong>Self-hosted mode:</strong> Make sure LibreTranslate is properly configured 
                                in <code>mainconfig.json</code> and the service is running.
                                Check <code>COMPONENTS.md</code> for setup instructions.
                            </p>
                        </div>
                    `;
                    // Rethrow to stop the translation process
                    throw error;
                })
                .then(() => {
                    // Show queuing message
                    transcriptContent.innerHTML = `
                        <div class="alert alert-info">
                            <div class="d-flex align-items-center">
                                <div class="spinner-border text-primary me-3" role="status" aria-hidden="true" style="width: 1.5rem; height: 1.5rem;"></div>
                                <div>
                                    <strong>Queuing translation...</strong><br>
                                    <small>Translation job is being queued for background processing. This may take a few moments.</small>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Queue the translation job
                    return fetch('/api/translate/queue', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            space_id: spaceId,
                            source_lang: sourceLang,
                            target_lang: targetLang
                        })
                    });
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        let errorMessage = data.error;
                        let helpText = '';
                        let setupInstructions = '';
                        
                        // Check for specific error types from our enhanced backend
                        if (data.details && data.details.setup_instructions) {
                            setupInstructions = `
                                <div class="mt-3 card border-info">
                                    <div class="card-header bg-info text-white">
                                        <i class="bi bi-info-circle-fill me-2"></i>Setup Instructions
                                    </div>
                                    <div class="card-body">
                                        <p class="mb-2"><strong>Option 1:</strong> ${data.details.setup_instructions.option1}</p>
                                        <p class="mb-0"><strong>Option 2:</strong> ${data.details.setup_instructions.option2}</p>
                                    </div>
                                </div>
                            `;
                        }
                        
                        if (data.details && data.details.suggestion) {
                            helpText = `
                                <p class="mt-2 mb-0">
                                    <strong>Suggestion:</strong> ${data.details.suggestion}
                                </p>
                            `;
                        }
                        
                        // Check for common error patterns
                        if (errorMessage.includes('API key required') || errorMessage.includes('Authentication') || 
                            errorMessage.includes('authentication') || errorMessage.includes('requires API key')) {
                            // Only show LibreTranslate setup if we're actually in self-hosted mode
                            if (info && info.self_hosted && info.provider === "None") {
                                errorMessage = 'Translation API key is required or self-hosted setup needed';
                                helpText = `
                                    <p class="mt-2 mb-0">
                                        <strong>Quick Fix:</strong> Run <code>./setup_libretranslate_no_docker.sh</code> in your terminal
                                        to set up a free local translation server (no Docker required).
                                    </p>
                                `;
                            } else {
                                errorMessage = 'Translation failed due to API configuration';
                                helpText = `
                                    <p class="mt-2 mb-0">
                                        The AI translation service encountered an error. This may be temporary.
                                    </p>
                                `;
                            }
                        } else if (errorMessage.includes('connection refused') || errorMessage.includes('not found') || 
                                  errorMessage.includes('unreachable') || errorMessage.includes('unavailable')) {
                            errorMessage = 'Translation service is not available';
                            helpText = `
                                <p class="mt-2 mb-0">
                                    <strong>Self-hosted mode:</strong> You need to start your LibreTranslate server.
                                    Run these commands to start it:
                                    <code>cd libretranslate && source venv/bin/activate && libretranslate --host localhost --port 5000</code>
                                </p>
                            `;
                        }
                        
                        transcriptContent.innerHTML = `
                            <div class="alert alert-danger">
                                <div><i class="bi bi-exclamation-triangle-fill me-2"></i> <strong>Translation Error:</strong> ${errorMessage}</div>
                                ${helpText}
                                ${setupInstructions}
                                <div class="mt-3">
                                    <a href="javascript:void(0)" onclick="resetTranscriptView()" class="btn btn-sm btn-outline-secondary">
                                        <i class="bi bi-arrow-return-left"></i> Return to Original Text
                                    </a>
                                    <a href="/TRANSLATION.md" target="_blank" class="btn btn-sm btn-outline-info ms-2">
                                        <i class="bi bi-question-circle"></i> View Translation Documentation
                                    </a>
                                </div>
                            </div>
                        `;
                    } else if (data.job_id) {
                        // Job queued successfully, start polling for status
                        console.log(`Translation job ${data.job_id} queued for space ${spaceId}`);
                        pollTranslationJob(data.job_id, spaceId, targetLang);
                    } else {
                        // Handle unexpected response
                        transcriptContent.innerHTML = `
                            <div class="alert alert-warning">
                                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                                Unexpected response from translation service. Please try again.
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error translating:', error);
                    transcriptContent.innerHTML = `
                        <div class="alert alert-danger">
                            <div><i class="bi bi-exclamation-triangle-fill me-2"></i> Translation failed</div>
                            <p class="mt-2 mb-0">An unexpected error occurred during translation. Please try again later.</p>
                        </div>
                    `;
                });
        }
        
        // Set up language selector
        const languageSelector = document.getElementById('language-selector');
        if (languageSelector) {
            // Update option text to show full language names
            for (let i = 0; i < languageSelector.options.length; i++) {
                const option = languageSelector.options[i];
                const langCode = option.getAttribute('data-language') || option.text;
                option.text = getLanguageName(langCode);
            }
            
            languageSelector.addEventListener('change', function() {
                loadTranscript(this.value);
            });
            
            // Load initial transcript
            if (languageSelector && languageSelector.options.length > 0) {
                console.log('Loading initial transcript with value:', languageSelector.value);
                loadTranscript(languageSelector.value);
            } else {
                console.log('No language selector or no options available');
                // Hide the loading spinner if no transcript is available
                const loader = document.querySelector('.transcript-loader');
                if (loader) {
                    loader.style.display = 'none';
                }
            }
        }
        
        // Set up transcript copy button
        const copyBtn = document.getElementById('transcript-copy-btn');
        if (copyBtn) {
            copyBtn.addEventListener('click', function() {
                const text = transcriptContent.innerText;
                navigator.clipboard.writeText(text).then(
                    function() {
                        // Temporarily change button text to show success
                        const originalText = copyBtn.innerHTML;
                        copyBtn.innerHTML = '<i class="bi bi-check"></i> Copied!';
                        setTimeout(() => {
                            copyBtn.innerHTML = originalText;
                        }, 2000);
                    },
                    function(err) {
                        console.error('Could not copy text: ', err);
                        alert('Failed to copy transcript to clipboard');
                    }
                );
            });
        }
        
        // Function to poll transcription progress for direct transcription
        function pollTranscriptionProgress(jobId) {
            const pollInterval = setInterval(function() {
                fetch(`/api/transcript_job/${jobId}`)
                    .then(response => response.json())
                    .then(jobData => {
                        // Update button text with progress
                        if (jobData.progress) {
                            transcribeBtn.innerHTML = `<i class="bi bi-hourglass-split"></i> Transcribing... ${jobData.progress}%`;
                        }
                        
                        if (jobData.status === 'completed') {
                            // Stop polling
                            clearInterval(pollInterval);
                            
                            // Update button to show transcription complete
                            transcribeBtn.disabled = true;
                            transcribeBtn.innerHTML = '<i class="bi bi-check-circle"></i> Transcribed';
                            transcribeBtn.setAttribute('data-has-transcript', 'true');
                            
                            // Show transcript section
                            transcriptSection.style.display = 'block';
                            
                            // Load transcript if available
                            if (jobData.result && jobData.result.transcript_id) {
                                loadTranscript(jobData.result.transcript_id);
                                
                                // Update language selector
                                let langSelector = document.getElementById('language-selector');
                                
                                // Create language selector if it doesn't exist
                                if (!langSelector) {
                                    // Find the container where we need to insert the selector
                                    const transcriptHeader = transcriptSection.querySelector('.card-header .d-flex.align-items-center');
                                    if (transcriptHeader) {
                                        // Create the selector
                                        langSelector = document.createElement('select');
                                        langSelector.id = 'language-selector';
                                        langSelector.className = 'form-select form-select-sm ms-3';
                                        langSelector.style.width = 'auto';
                                        
                                        // Add change event listener
                                        langSelector.addEventListener('change', function() {
                                            loadTranscript(this.value);
                                        });
                                        
                                        // Insert after the "Audio Transcript" span
                                        transcriptHeader.appendChild(langSelector);
                                    }
                                }
                                
                                if (langSelector) {
                                    // Check if option already exists
                                    let optionExists = false;
                                    for (let i = 0; i < langSelector.options.length; i++) {
                                        if (langSelector.options[i].value == jobData.result.transcript_id) {
                                            optionExists = true;
                                            langSelector.selectedIndex = i;
                                            break;
                                        }
                                    }
                                    
                                    if (!optionExists) {
                                        // Add new option
                                        const option = document.createElement('option');
                                        option.value = jobData.result.transcript_id;
                                        option.setAttribute('data-language', jobData.result.language);
                                        option.text = getLanguageName(jobData.result.language);
                                        option.selected = true;
                                        langSelector.appendChild(option);
                                    }
                                }
                            }
                            
                            // Show notification
                            if ('Notification' in window && Notification.permission === 'granted') {
                                new Notification('Transcription Complete', {
                                    body: 'The audio has been successfully transcribed.',
                                    icon: '/static/favicon.ico'
                                });
                            }
                        } else if (jobData.status === 'failed') {
                            // Stop polling
                            clearInterval(pollInterval);
                            
                            // Reset button only if no existing transcript
                            if (transcribeBtn.getAttribute('data-has-transcript') !== 'true') {
                                transcribeBtn.disabled = false;
                                transcribeBtn.innerHTML = '<i class="bi bi-mic"></i> Transcribe';
                            } else {
                                transcribeBtn.disabled = true;
                                transcribeBtn.innerHTML = '<i class="bi bi-check-circle"></i> Transcribed';
                            }
                            
                            // Show error
                            alert('Transcription failed: ' + (jobData.error || 'Unknown error occurred'));
                        }
                    })
                    .catch(error => {
                        console.error('Error polling transcription progress:', error);
                        // Continue polling on network errors
                    });
            }, 2000); // Poll every 2 seconds
        }
        
        // Set up translation functionality
        const translateBtn = document.getElementById('translate-btn');
        const translateSelect = document.getElementById('translate-target-lang');
        
        if (translateBtn && translateSelect) {
            translateBtn.addEventListener('click', function() {
                const targetLang = translateSelect.value;
                
                if (!targetLang) {
                    alert('Please select a language to translate to');
                    return;
                }
                
                // Get source language from data attribute or fallback to 'en'
                const sourceLang = transcriptContent.getAttribute('data-source-lang') || 'en';
                
                // Skip if source and target are the same
                if (sourceLang === targetLang) {
                    alert('Source and target languages are the same');
                    return;
                }
                
                // Get original text from JavaScript variable (most reliable)
                let sourceText = fullTranscriptText;
                
                // Fallback to data attributes if JavaScript variable is empty
                if (!sourceText) {
                    sourceText = transcriptContent.getAttribute('data-original-text');
                }
                
                // If still not found, try from the transcript text div
                if (!sourceText) {
                    const transcriptTextDiv = transcriptContent.querySelector('.transcript-text');
                    if (transcriptTextDiv && transcriptTextDiv.hasAttribute('data-original-text')) {
                        sourceText = transcriptTextDiv.getAttribute('data-original-text');
                    }
                }
                
                // Final fallback to current text content
                if (!sourceText) {
                    sourceText = transcriptContent.innerText.replace(/\s+/g, ' ').trim();
                }
                
                if (!sourceText) {
                    alert('No text to translate');
                    return;
                }
                
                // Debug logging
                console.log('Translation request - Text length:', sourceText.length);
                console.log('First 200 chars:', sourceText.substring(0, 200));
                console.log('Last 200 chars:', sourceText.substring(sourceText.length - 200));
                
                // Check translation service info first
                fetch('/api/translate/info')
                    .then(response => response.json())
                    .then(info => {
                        // Only show resource warning for self-hosted mode without AI APIs
                        const isAiAvailable = info.api_key_configured && info.provider !== "None";
                        const isLargeText = sourceText.length > 10000;
                        
                        if (isLargeText && !isAiAvailable && info.self_hosted) {
                            // Only warn for self-hosted mode without AI APIs
                            if (!confirm('The transcript is quite large (' + Math.round(sourceText.length/1000) + 'K characters). ' +
                                      'In self-hosted mode, this might cause issues if your server has limited resources. Continue anyway?')) {
                                return;
                            }
                        }
                        
                        // Proceed with translation
                        performTranslation(sourceText, sourceLang, targetLang);
                    })
                    .catch(error => {
                        console.warn('Could not check translation service info:', error);
                        // Proceed anyway if we can't check
                        performTranslation(sourceText, sourceLang, targetLang);
                    });
            });
        }
        
        // Helper function for translation
        function performTranslation(sourceText, sourceLang, targetLang) {
            // Call translation function
            translateTranscript(sourceText, sourceLang, targetLang);
        }
        
        // Set up summarize button
        if (summarizeBtn) {
            summarizeBtn.addEventListener('click', function() {
                // Check if there's any transcript content
                if (!transcriptContent || !transcriptContent.innerText.trim()) {
                    showToast('No transcript content to summarize', 'warning');
                    return;
                }
                
                // Get current displayed text and determine if it's translated
                const currentText = transcriptContent.innerText.trim();
                const translatedDiv = transcriptContent.querySelector('.transcript-text.translated');
                const isTranslated = translatedDiv !== null;
                
                // Determine the language of current content
                let contentLanguage = 'en'; // default
                
                if (isTranslated) {
                    // If showing translated text, just send the translated text to summarize
                    // The AI will naturally summarize in the same language as the input
                    
                    // Disable button and show loading state
                    summarizeBtn.disabled = true;
                    summarizeBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Summarizing...';
                    
                    console.log('Summarizing translated text...');
                    console.log('Text preview:', currentText.substring(0, 200) + '...');
                    
                    const requestBody = {
                        text: currentText,
                        max_length: 200,
                        space_id: '{{ space.space_id }}'
                        // No language parameter needed - AI will use the language of the input text
                    };
                    
                    fetch('/api/summary', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log('[SUMMARY RESPONSE] Received from API:', data);
                        
                        // Reset button
                        summarizeBtn.disabled = false;
                        summarizeBtn.innerHTML = '<i class="bi bi-lightbulb"></i>';
                        
                        if (data.success) {
                            // Format data to match transcript summary format
                            const formattedData = {
                                success: true,
                                summary: data.summary,
                                language: data.language || 'unknown',
                                space_id: spaceId,
                                summary_length: data.summary_length,
                                from_database: false
                            };
                            showSummaryModal(formattedData);
                            showToast('Summary generated successfully', 'success');
                        } else {
                            console.error('Summary failed:', data.error);
                            showToast('Summary failed: ' + (data.error || 'Unknown error'), 'danger');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        summarizeBtn.disabled = false;
                        summarizeBtn.innerHTML = '<i class="bi bi-lightbulb"></i>';
                        showToast('Error generating summary: ' + error.message, 'danger');
                    });
                    
                } else {
                    // If showing original transcript, use the transcript summary API
                    const languageSelector = document.getElementById('language-selector');
                    
                    // Handle case where language selector doesn't exist or has no value
                    let transcriptId = null;
                    
                    if (languageSelector && languageSelector.value) {
                        transcriptId = languageSelector.value;
                    } else {
                        // Try to get the transcript ID from the current transcript display
                        // This handles the case where transcript exists but selector is not populated
                        const transcriptDisplay = document.getElementById('transcript-section');
                        if (transcriptDisplay && transcriptDisplay.style.display !== 'none') {
                            // Check if we have transcript data stored
                            // First check if there's a selected option in case selector exists but no value
                            if (languageSelector && languageSelector.options.length > 0) {
                                // Select the first option if none selected
                                languageSelector.selectedIndex = 0;
                                transcriptId = languageSelector.value;
                            } else {
                                // No selector or empty selector, but transcript is displayed
                                // This shouldn't happen in normal flow, but let's handle it
                                showToast('Unable to identify transcript. Please refresh the page.', 'warning');
                                return;
                            }
                        } else {
                            showToast('Please select a transcript first', 'warning');
                            return;
                        }
                    }
                    
                    if (!transcriptId) {
                        showToast('Please select a transcript first', 'warning');
                        return;
                    }
                    
                    // Disable button and show loading state
                    summarizeBtn.disabled = true;
                    summarizeBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Summarizing...';
                    
                    // Make API request to get or generate summary
                    fetch(`/api/transcript/${transcriptId}/summary`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            max_length: 200,  // Default to 200 words
                            force_regenerate: false
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        // Reset button
                        summarizeBtn.disabled = false;
                        summarizeBtn.innerHTML = '<i class="bi bi-lightbulb"></i>';
                        
                        if (data.success) {
                            // Show summary in a modal or alert
                            showSummaryModal(data);
                            
                            // Show appropriate toast message
                            if (data.from_database) {
                                showToast('Summary loaded from database', 'success');
                            } else {
                                showToast('Summary generated successfully', 'success');
                            }
                            
                        } else {
                            console.error('Summary failed:', data.error);
                            showToast('Summary failed: ' + (data.error || 'Unknown error'), 'danger');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        // Reset button
                        summarizeBtn.disabled = false;
                        summarizeBtn.innerHTML = '<i class="bi bi-lightbulb"></i>';
                        showToast('Error generating summary: ' + error.message, 'danger');
                    });
                }
            });
        }
        
        // Function to show summary as slideshow
        function showSummaryModal(data) {
            // Parse summary into bullet points or sentences
            const summaryPoints = parseSummaryIntoPoints(data.summary);
            
            // Store summary data globally
            window.currentSummaryData = data;
            window.summaryPoints = summaryPoints;
            window.currentSlide = 0;
            
            // Create slideshow HTML
            const slideshowHtml = `
                <div id="summarySlideshow" class="summary-slideshow">
                    <!-- Overlay background -->
                    <div class="slideshow-overlay" id="slideshow-overlay"></div>
                    
                    <!-- Main slideshow container -->
                    <div class="slideshow-container">
                        <!-- Header -->
                        <div class="slideshow-header">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h5 class="mb-1">
                                        <i class="bi bi-file-earmark-text"></i> Transcript Summary
                                        ${data.from_database ? '<span class="badge bg-success ms-2">From Database</span>' : '<span class="badge bg-primary ms-2">AI Generated</span>'}
                                    </h5>
                                    <small class="text-muted">
                                        Language: ${data.language} | 
                                        ${summaryPoints.length} points |
                                        ${data.summary_length.toLocaleString()} chars
                                    </small>
                                </div>
                                <button class="btn btn-sm btn-outline-secondary" id="close-slideshow-btn">
                                    <i class="bi bi-x-lg"></i> Close
                                </button>
                            </div>
                        </div>
                        
                        <!-- Slide content -->
                        <div class="slideshow-content">
                            <div class="slide-counter">
                                <span id="slide-counter-text">1 / ${summaryPoints.length}</span>
                            </div>
                            
                            <div class="slide-area" id="slide-area">
                                <!-- Slides will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Navigation -->
                        <div class="slideshow-navigation">
                            <button class="btn btn-outline-primary" id="prev-slide">
                                <i class="bi bi-chevron-left"></i> Previous
                            </button>
                            
                            <div class="slide-indicators" id="slide-indicators">
                                <!-- Indicators will be populated here -->
                            </div>
                            
                            <button class="btn btn-outline-primary" id="next-slide">
                                Next <i class="bi bi-chevron-right"></i>
                            </button>
                        </div>
                        
                        <!-- Actions -->
                        <div class="slideshow-actions">
                            <button class="btn btn-sm btn-outline-secondary" id="copy-summary-btn">
                                <i class="bi bi-clipboard"></i> Copy All
                            </button>
                            <button class="btn btn-sm btn-outline-primary" id="download-summary-btn">
                                <i class="bi bi-download"></i> Download
                            </button>
                            <button class="btn btn-sm btn-outline-info" id="autoplay-btn">
                                <i class="bi bi-play"></i> <span id="autoplay-text">Auto Play</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add CSS for slideshow
            const slideshowCSS = `
                <style>
                .summary-slideshow {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                
                .slideshow-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    backdrop-filter: blur(5px);
                }
                
                .slideshow-container {
                    position: relative;
                    width: 90%;
                    max-width: 800px;
                    height: 80%;
                    background: white;
                    border-radius: 15px;
                    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                }
                
                .slideshow-header {
                    padding: 20px 25px 15px;
                    border-bottom: 1px solid #dee2e6;
                    background: #f8f9fa;
                }
                
                .slideshow-content {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    min-height: 0;
                }
                
                .slide-counter {
                    padding: 15px 25px 10px;
                    text-align: center;
                    font-size: 0.9rem;
                    color: #6c757d;
                    border-bottom: 1px solid #e9ecef;
                }
                
                .slide-area {
                    flex: 1;
                    padding: 20px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    overflow-y: auto;
                    background: linear-gradient(45deg, #f0f2f5 0%, #e8ebf0 100%);
                }
                
                .slide {
                    display: none;
                    font-size: 1.4rem;
                    line-height: 1.8;
                    font-weight: 500;
                    text-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    animation: slideIn 0.6s ease-in-out;
                    max-width: 90%;
                    min-height: 200px;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    position: relative;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255,255,255,0.2);
                }
                
                .slide.active {
                    display: flex;
                }
                
                .slide::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: inherit;
                    border-radius: inherit;
                    filter: blur(20px);
                    opacity: 0.3;
                    z-index: -1;
                }
                
                @keyframes slideIn {
                    from {
                        opacity: 0;
                        transform: translateY(30px) scale(0.95);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0) scale(1);
                    }
                }
                
                .slideshow-navigation {
                    padding: 15px 25px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-top: 1px solid #dee2e6;
                    background: #f8f9fa;
                }
                
                .slide-indicators {
                    display: flex;
                    gap: 8px;
                }
                
                .slide-indicator {
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: #dee2e6;
                    cursor: pointer;
                    transition: all 0.3s ease;
                }
                
                .slide-indicator.active {
                    background: #007bff;
                    transform: scale(1.2);
                }
                
                .slideshow-actions {
                    padding: 15px 25px;
                    display: flex;
                    justify-content: center;
                    gap: 10px;
                    border-top: 1px solid #dee2e6;
                }
                
                @media (max-width: 768px) {
                    .slideshow-container {
                        width: 95%;
                        height: 85%;
                    }
                    
                    .slide-area {
                        padding: 20px 20px;
                        font-size: 1.1rem;
                    }
                    
                    .slideshow-navigation {
                        flex-direction: column;
                        gap: 15px;
                    }
                    
                    .slideshow-actions {
                        flex-wrap: wrap;
                        gap: 8px;
                    }
                }
                </style>
            `;
            
            // Remove any existing slideshow
            const existingSlideshow = document.getElementById('summarySlideshow');
            if (existingSlideshow) {
                existingSlideshow.remove();
            }
            
            // Add CSS and slideshow to body
            document.head.insertAdjacentHTML('beforeend', slideshowCSS);
            document.body.insertAdjacentHTML('beforeend', slideshowHtml);
            
            // Initialize slideshow
            initializeSlideshow();
            
            // Add keyboard navigation
            document.addEventListener('keydown', handleSlideshowKeyboard);
            
            // Make sure functions are globally available for any inline calls
            window.toggleAutoplay = toggleAutoplay;
            window.copySummaryToClipboard = copySummaryToClipboard;
            window.downloadSummary = downloadSummary;
            window.changeSlide = changeSlide;
            window.goToSlide = goToSlide;
            window.closeSummarySlideshow = closeSummarySlideshow;
        }
        
        // Function to parse summary into individual points
        function parseSummaryIntoPoints(summary) {
            // Ensure summary is a string
            if (typeof summary !== 'string') {
                console.error('Summary is not a string:', summary);
                // Try to extract summary content if it's an object
                if (typeof summary === 'object' && summary !== null) {
                    if (summary.content) {
                        summary = summary.content;
                    } else if (summary.summary) {
                        summary = summary.summary;
                    } else {
                        summary = JSON.stringify(summary);
                    }
                } else {
                    summary = String(summary || 'Unable to parse summary');
                }
            }
            
            // Split by bullet points, numbered lists, or sentences
            let points = [];
            
            // First, try to split by bullet points or numbered lists
            if (summary.includes('•') || summary.includes('*') || summary.includes('-')) {
                points = summary.split(/[•*-]\s+/).filter(point => point.trim().length > 0);
            } else if (/^\d+\./.test(summary)) {
                points = summary.split(/\d+\.\s+/).filter(point => point.trim().length > 0);
            } else {
                // Fall back to sentences
                points = summary.split(/[.!?]+/).filter(point => point.trim().length > 20);
            }
            
            // Clean up points and ensure each is substantial
            points = points.map(point => point.trim().replace(/\n+/g, ' '))
                          .filter(point => point.length > 10)
                          .map(point => {
                              // Add period if missing
                              if (!point.match(/[.!?]$/)) {
                                  point += '.';
                              }
                              return point;
                          });
            
            // If we have too few points, create them artificially
            if (points.length < 3) {
                const sentences = summary.split(/[.!?]+/).filter(s => s.trim().length > 15);
                if (sentences.length > 1) {
                    points = sentences.map(s => s.trim()).filter(s => s.length > 0);
                } else {
                    // Single block - split into chunks
                    const words = summary.trim().split(' ');
                    const chunkSize = Math.ceil(words.length / 3);
                    points = [];
                    for (let i = 0; i < words.length; i += chunkSize) {
                        const chunk = words.slice(i, i + chunkSize).join(' ');
                        if (chunk.trim().length > 10) {
                            points.push(chunk.trim() + (chunk.match(/[.!?]$/) ? '' : '.'));
                        }
                    }
                }
            }
            
            return points.length > 0 ? points : [summary];
        }
        
        // Initialize slideshow functionality
        function initializeSlideshow() {
            console.log('Initializing slideshow with', window.summaryPoints.length, 'points');
            
            const slideArea = document.getElementById('slide-area');
            const slideIndicators = document.getElementById('slide-indicators');
            
            if (!slideArea || !slideIndicators) {
                console.error('Slide area or indicators not found');
                return;
            }
            
            // Clear existing content
            slideArea.innerHTML = '';
            slideIndicators.innerHTML = '';
            
            // Create slides with background themes
            window.summaryPoints.forEach((point, index) => {
                console.log('Creating slide', index, 'with content:', point.substring(0, 50) + '...');
                // Create slide
                const slide = document.createElement('div');
                slide.className = `slide ${index === 0 ? 'active' : ''}`;
                slide.innerHTML = point;
                
                // Add background gradient based on slide index
                const backgroundStyle = getSlideBackground(index);
                slide.style.background = backgroundStyle;
                slide.style.borderRadius = '15px';
                slide.style.padding = '40px';
                slide.style.margin = '20px';
                slide.style.boxShadow = '0 8px 32px rgba(0,0,0,0.1)';
                slide.style.color = getTextColorForBackground(index);
                
                slideArea.appendChild(slide);
                
                // Create indicator
                const indicator = document.createElement('div');
                indicator.className = `slide-indicator ${index === 0 ? 'active' : ''}`;
                indicator.addEventListener('click', () => {
                    console.log('Indicator clicked for slide', index);
                    goToSlide(index);
                });
                slideIndicators.appendChild(indicator);
            });
            
            // Add event listeners to all buttons
            setTimeout(() => {
                const prevBtn = document.getElementById('prev-slide');
                const nextBtn = document.getElementById('next-slide');
                const copyBtn = document.getElementById('copy-summary-btn');
                const downloadBtn = document.getElementById('download-summary-btn');
                const autoplayBtn = document.getElementById('autoplay-btn');
                
                if (prevBtn) {
                    prevBtn.removeAttribute('onclick'); // Remove any inline onclick
                    prevBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        changeSlide(-1);
                    });
                }
                if (nextBtn) {
                    nextBtn.removeAttribute('onclick');
                    nextBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        changeSlide(1);
                    });
                }
                if (copyBtn) {
                    copyBtn.removeAttribute('onclick');
                    copyBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        copySummaryToClipboard();
                    });
                }
                if (downloadBtn) {
                    downloadBtn.removeAttribute('onclick');
                    downloadBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        downloadSummary();
                    });
                }
                if (autoplayBtn) {
                    autoplayBtn.removeAttribute('onclick');
                    autoplayBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleAutoplay();
                    });
                }
                
                // Add overlay click handler
                const overlay = document.getElementById('slideshow-overlay');
                if (overlay) {
                    overlay.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        closeSummarySlideshow();
                    });
                }
                
                // Add close button handler
                const closeBtn = document.getElementById('close-slideshow-btn');
                if (closeBtn) {
                    closeBtn.removeAttribute('onclick');
                    closeBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        closeSummarySlideshow();
                    });
                }
            }, 100); // Small delay to ensure DOM is ready
            
            // Update navigation buttons
            updateNavigationButtons();
        }
        
        // Get background gradient for slide based on content
        function getSlideBackground(index) {
            // Analyze the content to determine theme
            const slideContent = window.summaryPoints[index].toLowerCase();
            const themeBackgrounds = getThemeBasedBackground(slideContent);
            
            if (themeBackgrounds.length > 0) {
                return themeBackgrounds[index % themeBackgrounds.length];
            }
            
            // Fallback to beautiful gradient collection
            const backgrounds = [
                'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', // Purple-Blue (Tech)
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', // Pink-Red (Creative)
                'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)', // Blue (Business)
                'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)', // Green (Health/Nature)
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)', // Pink-Yellow (Energy)
                'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)', // Mint-Pink (Soft)
                'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)', // Coral-Pink (Warm)
                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)', // Peach (Friendly)
                'linear-gradient(135deg, #ff8177 0%, #ff867a 0%, #ff8c7f 21%, #f99185 52%, #cf556c 78%, #b12a5b 100%)', // Sunset
                'linear-gradient(135deg, #ebbba7 0%, #cfc7f8 100%)', // Lavender
                'linear-gradient(135deg, #fff1eb 0%, #ace0f9 100%)', // Cloud-Sky
                'linear-gradient(135deg, #74b9ff 0%, #0984e3 100%)', // Ocean Blue
                'linear-gradient(135deg, #fd79a8 0%, #e84393 100%)', // Magenta
                'linear-gradient(135deg, #fdcb6e 0%, #e17055 100%)', // Orange-Red
                'linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%)' // Purple
            ];
            
            return backgrounds[index % backgrounds.length];
        }
        
        // Get theme-based backgrounds based on content analysis
        function getThemeBasedBackground(content) {
            // Technology themes
            if (content.match(/\b(technology|tech|software|app|digital|AI|artificial intelligence|machine learning|coding|programming|data|algorithm|computer|internet|web|mobile|startup|innovation)\b/i)) {
                return [
                    'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    'linear-gradient(135deg, #74b9ff 0%, #0984e3 100%)',
                    'linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%)'
                ];
            }
            
            // Business/Finance themes
            if (content.match(/\b(business|finance|money|investment|market|economy|profit|revenue|growth|strategy|company|corporate|leadership|management|sales)\b/i)) {
                return [
                    'linear-gradient(135deg, #2d3436 0%, #636e72 100%)',
                    'linear-gradient(135deg, #74b9ff 0%, #0984e3 100%)',
                    'linear-gradient(135deg, #00b894 0%, #00cec9 100%)',
                    'linear-gradient(135deg, #fdcb6e 0%, #e17055 100%)'
                ];
            }
            
            // Health/Wellness themes
            if (content.match(/\b(health|wellness|fitness|medical|doctor|hospital|therapy|nutrition|exercise|mental|physical|healing|medicine|treatment)\b/i)) {
                return [
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                    'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                    'linear-gradient(135deg, #81ecec 0%, #74b9ff 100%)',
                    'linear-gradient(135deg, #55efc4 0%, #81ecec 100%)'
                ];
            }
            
            // Creative/Art themes
            if (content.match(/\b(art|creative|design|music|painting|drawing|photography|writing|artist|creative|aesthetic|beauty|color|visual)\b/i)) {
                return [
                    'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
                    'linear-gradient(135deg, #fd79a8 0%, #e84393 100%)'
                ];
            }
            
            // Education/Learning themes
            if (content.match(/\b(education|learning|school|university|student|teacher|knowledge|study|research|academic|science|discovery|book|reading)\b/i)) {
                return [
                    'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
                    'linear-gradient(135deg, #fff1eb 0%, #ace0f9 100%)',
                    'linear-gradient(135deg, #ebbba7 0%, #cfc7f8 100%)',
                    'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'
                ];
            }
            
            // Travel/Adventure themes
            if (content.match(/\b(travel|adventure|journey|explore|destination|vacation|trip|world|country|culture|experience|discover)\b/i)) {
                return [
                    'linear-gradient(135deg, #ff8177 0%, #ff867a 0%, #ff8c7f 21%, #f99185 52%, #cf556c 78%, #b12a5b 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                    'linear-gradient(135deg, #74b9ff 0%, #0984e3 100%)'
                ];
            }
            
            // Food/Cooking themes
            if (content.match(/\b(food|cooking|recipe|restaurant|chef|cuisine|meal|delicious|flavor|taste|kitchen|dining|ingredient)\b/i)) {
                return [
                    'linear-gradient(135deg, #fdcb6e 0%, #e17055 100%)',
                    'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)'
                ];
            }
            
            return []; // Return empty array if no theme matches
        }
        
        // Get appropriate text color for background
        function getTextColorForBackground(index) {
            // Alternate between white and dark text based on background
            const lightBackgrounds = [5, 6, 7, 10]; // Indices of lighter backgrounds
            
            if (lightBackgrounds.includes(index % 15)) {
                return '#2d3436'; // Dark text for light backgrounds
            } else {
                return '#ffffff'; // White text for dark backgrounds
            }
        }
        
        // Change slide function
        function changeSlide(direction) {
            console.log('changeSlide called with direction:', direction, 'current slide:', window.currentSlide);
            
            // Safety checks
            if (!window.summaryPoints || !Array.isArray(window.summaryPoints)) {
                console.error('Cannot change slide: summaryPoints not available');
                return;
            }
            
            if (typeof window.currentSlide === 'undefined') {
                console.error('Cannot change slide: currentSlide not defined');
                window.currentSlide = 0; // Reset to first slide
                return;
            }
            
            const newSlide = window.currentSlide + direction;
            
            if (newSlide >= 0 && newSlide < window.summaryPoints.length) {
                goToSlide(newSlide);
            } else {
                console.log('Cannot change slide - out of bounds:', newSlide, 'max:', window.summaryPoints.length - 1);
            }
        }
        
        // Go to specific slide
        function goToSlide(slideIndex) {
            console.log('goToSlide called with index:', slideIndex);
            
            // Safety checks
            if (!window.summaryPoints || !Array.isArray(window.summaryPoints)) {
                console.error('Cannot go to slide: summaryPoints not available');
                return;
            }
            
            if (slideIndex < 0 || slideIndex >= window.summaryPoints.length) {
                console.error('Cannot go to slide: index out of bounds', slideIndex);
                return;
            }
            
            // Update current slide
            window.currentSlide = slideIndex;
            
            // Update slides
            const slides = document.querySelectorAll('#summarySlideshow .slide');
            const indicators = document.querySelectorAll('#summarySlideshow .slide-indicator');
            
            console.log('Found slides:', slides.length, 'indicators:', indicators.length);
            
            slides.forEach((slide, index) => {
                if (index === slideIndex) {
                    slide.classList.add('active');
                    console.log('Activated slide', index);
                } else {
                    slide.classList.remove('active');
                }
            });
            
            indicators.forEach((indicator, index) => {
                if (index === slideIndex) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                }
            });
            
            // Update counter
            const counterElement = document.getElementById('slide-counter-text');
            if (counterElement && window.summaryPoints) {
                counterElement.textContent = `${slideIndex + 1} / ${window.summaryPoints.length}`;
            }
            
            // Update navigation buttons
            updateNavigationButtons();
        }
        
        // Update navigation button states
        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prev-slide');
            const nextBtn = document.getElementById('next-slide');
            
            // Safety checks
            if (!window.summaryPoints || typeof window.currentSlide === 'undefined') {
                if (prevBtn) prevBtn.disabled = true;
                if (nextBtn) nextBtn.disabled = true;
                return;
            }
            
            if (prevBtn) prevBtn.disabled = window.currentSlide === 0;
            if (nextBtn) nextBtn.disabled = window.currentSlide === window.summaryPoints.length - 1;
        }
        
        // Handle keyboard navigation
        function handleSlideshowKeyboard(event) {
            if (!document.getElementById('summarySlideshow')) return;
            
            // Safety check for summaryPoints
            if (!window.summaryPoints || !Array.isArray(window.summaryPoints)) {
                console.warn('Keyboard navigation disabled: summaryPoints not available');
                return;
            }
            
            switch(event.key) {
                case 'ArrowLeft':
                case 'ArrowUp':
                    event.preventDefault();
                    changeSlide(-1);
                    break;
                case 'ArrowRight':
                case 'ArrowDown':
                case ' ':
                    event.preventDefault();
                    changeSlide(1);
                    break;
                case 'Escape':
                    event.preventDefault();
                    closeSummarySlideshow();
                    break;
                case 'Home':
                    event.preventDefault();
                    goToSlide(0);
                    break;
                case 'End':
                    event.preventDefault();
                    goToSlide(window.summaryPoints.length - 1);
                    break;
            }
        }
        
        // Close slideshow
        function closeSummarySlideshow() {
            const slideshow = document.getElementById('summarySlideshow');
            if (slideshow) {
                slideshow.remove();
            }
            
            // Remove keyboard listener
            document.removeEventListener('keydown', handleSlideshowKeyboard);
            
            // Clean up global variables
            delete window.currentSummaryData;
            delete window.summaryPoints;
            delete window.currentSlide;
            delete window.autoplayInterval;
        }
        
        // Autoplay functionality
        function toggleAutoplay() {
            const autoplayText = document.querySelector('#autoplay-text');
            const autoplayIcon = document.querySelector('#autoplay-btn i');
            
            // Safety check - ensure we have the required data
            if (!window.summaryPoints || !Array.isArray(window.summaryPoints) || window.summaryPoints.length === 0) {
                console.error('Cannot start autoplay: summaryPoints not available');
                return;
            }
            
            if (window.autoplayInterval) {
                // Stop autoplay
                clearInterval(window.autoplayInterval);
                delete window.autoplayInterval;
                if (autoplayText) autoplayText.textContent = 'Auto Play';
                if (autoplayIcon) autoplayIcon.className = 'bi bi-play';
                console.log('Autoplay stopped');
            } else {
                // Start autoplay
                window.autoplayInterval = setInterval(() => {
                    // Additional safety check inside the interval
                    if (!window.summaryPoints || typeof window.currentSlide === 'undefined') {
                        console.error('Autoplay stopped: missing data');
                        clearInterval(window.autoplayInterval);
                        delete window.autoplayInterval;
                        return;
                    }
                    
                    if (window.currentSlide < window.summaryPoints.length - 1) {
                        changeSlide(1);
                    } else {
                        // Loop back to start
                        goToSlide(0);
                    }
                }, 4000); // 4 seconds per slide
                
                if (autoplayText) autoplayText.textContent = 'Stop';
                if (autoplayIcon) autoplayIcon.className = 'bi bi-pause';
                console.log('Autoplay started');
            }
        }
        
        // Function to copy summary to clipboard
        function copySummaryToClipboard() {
            if (window.currentSummaryData) {
                navigator.clipboard.writeText(window.currentSummaryData.summary).then(() => {
                    showToast('Summary copied to clipboard', 'success');
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    showToast('Failed to copy summary', 'danger');
                });
            }
        }
        
        // Function to download summary
        function downloadSummary() {
            if (window.currentSummaryData) {
                const blob = new Blob([window.currentSummaryData.summary], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `summary_${window.currentSummaryData.space_id}_${window.currentSummaryData.language}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }
        
        // Set up transcript download button
        const downloadBtn = document.getElementById('transcript-download-btn');
        if (downloadBtn) {
            downloadBtn.addEventListener('click', function() {
                const text = transcriptContent.innerText;
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `transcript_${spaceId}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }
        
        // Download status tracking
        if (window.spaceStatus === 'pending' || window.spaceStatus === 'downloading' || window.spaceStatus === 'in_progress') {
            // Function to format file size
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';
                
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            
            // Function to update download status
            function updateDownloadStatus() {
                $.ajax({
                    url: '/api/space_status/' + spaceId,
                    type: 'GET',
                    dataType: 'json',
                    success: function(data) {
                        // If file exists and status is completed, reload the page
                        if (data.file_exists && data.status === 'completed') {
                            window.location.reload();
                            return;
                        }
                        
                        // Update status based on job data
                        if (data.job_status === 'in_progress' || data.job_status === 'downloading') {
                            // Show progress container if it's hidden
                            $('#progress-container').removeClass('d-none');
                            
                            // Update progress bar
                            const percent = data.progress_in_percent || 0;
                            $('#progress-bar').css('width', percent + '%');
                            $('#progress-bar').attr('aria-valuenow', percent);
                            $('#progress-bar').text(percent + '%');
                            $('#progress-percent').text(percent);
                            
                            // Update download size
                            if (data.progress_in_size) {
                                const sizeMB = (data.progress_in_size / (1024*1024)).toFixed(2);
                                $('#progress-size').text(`Downloaded ${formatBytes(data.progress_in_size)} (${sizeMB} MB)`);
                            }
                            
                            // Update message
                            $('#download-message').text('This space is currently being downloaded. You\'ll be able to listen to it once the download is complete.');
                        } 
                        else if (data.job_status === 'pending') {
                            $('#download-message').text('This space is in the download queue. The download will start automatically.');
                        }
                        else if (data.job_status === 'failed') {
                            // Update container class
                            $('#download-status-container').removeClass('alert-info').addClass('alert-danger');
                            
                            // Use the user-friendly error message from the backend
                            let errorMessage = data.error_message || 'The download for this space failed for an unknown reason.';
                            
                            // Update the message
                            $('#download-message').html(errorMessage + '<br><br>You can try downloading it again later.');
                            
                            // Show a try again button
                            if (!$('#try-again-btn').length) {
                                const tryAgainBtn = $('<a>', {
                                    href: "{{ url_for('submit_space') }}?space_url={{ space.space_url|urlencode }}",
                                    class: 'btn btn-primary mt-3',
                                    id: 'try-again-btn',
                                    text: 'Try Downloading Again'
                                });
                                $('#download-message').after(tryAgainBtn);
                            }
                        }
                    },
                    error: function(xhr, status, error) {
                        console.error('Error fetching space status:', error);
                    }
                });
            }
            
            // Update status when page loads
            updateDownloadStatus();
            
            // Variable to store the interval ID so we can clear it
            let statusInterval;
            
            // Function to check status and decide whether to continue polling
            function checkStatusAndUpdate() {
                $.ajax({
                    url: '/api/space_status/' + spaceId,
                    type: 'GET',
                    dataType: 'json',
                    success: function(data) {
                        // If the download is complete or failed, stop polling
                        if ((data.status === 'completed' || data.file_exists) || 
                            data.status === 'failed' || 
                            data.progress_in_percent >= 100) {
                            console.log('Download complete or failed, stopping automatic updates');
                            clearInterval(statusInterval);
                            
                            // Perform one final update
                            updateDownloadStatus();
                            
                            // If file exists and status is completed, reload after a short delay
                            if (data.file_exists && data.status === 'completed') {
                                setTimeout(function() {
                                    window.location.reload();
                                }, 1000);
                            }
                        } else {
                            // Still in progress, continue with normal updates
                            updateDownloadStatus();
                        }
                    },
                    error: function(xhr, status, error) {
                        console.error('Error checking space status:', error);
                        // Continue with normal updates even on error
                        updateDownloadStatus();
                    }
                });
            }
            
            // Set interval for updates (every 5 seconds)
            statusInterval = setInterval(checkStatusAndUpdate, 5000);
        }
        
        // Title editing functionality
        const editTitleBtn = document.getElementById('edit-title-btn');
        const spaceTitle = document.getElementById('space-title');
        // spaceId is already declared above, no need to redeclare
        
        if (editTitleBtn && spaceTitle) {
            editTitleBtn.addEventListener('click', function() {
                const currentTitle = spaceTitle.textContent.trim();
                
                // Create input field
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'form-control form-control-sm d-inline-block';
                input.style.width = '300px';
                input.value = currentTitle;
                input.placeholder = 'Enter space title...';
                
                // Create save and cancel buttons
                const saveBtn = document.createElement('button');
                saveBtn.className = 'btn btn-success btn-sm ms-2';
                saveBtn.innerHTML = '<i class="bi bi-check"></i>';
                saveBtn.title = 'Save';
                
                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn btn-secondary btn-sm ms-1';
                cancelBtn.innerHTML = '<i class="bi bi-x"></i>';
                cancelBtn.title = 'Cancel';
                
                // Hide title and edit button
                spaceTitle.style.display = 'none';
                editTitleBtn.style.display = 'none';
                
                // Create container for input and buttons
                const editContainer = document.createElement('div');
                editContainer.className = 'd-inline-flex align-items-center';
                editContainer.appendChild(input);
                editContainer.appendChild(saveBtn);
                editContainer.appendChild(cancelBtn);
                
                // Insert edit container
                spaceTitle.parentNode.insertBefore(editContainer, spaceTitle);
                
                // Focus input
                input.focus();
                input.select();
                
                // Save function
                function saveTitle() {
                    const newTitle = input.value.trim();
                    const cookieId = window.getCookieId();
                    
                    // Make API request to update title
                    fetch(`/api/space/${spaceId}/title`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            title: newTitle,
                            cookie_id: cookieId
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Update display
                            spaceTitle.textContent = newTitle || `Space ${spaceId}`;
                            
                            // Update page title
                            document.title = `${newTitle || spaceId} - XSpace Downloader`;
                            
                            // Update audio player title if exists
                            const audioPlayerTitle = document.querySelector('.audio-player .card-header span');
                            if (audioPlayerTitle) {
                                audioPlayerTitle.textContent = newTitle || `Space ${spaceId}`;
                            }
                            
                            showToast('Title updated successfully', 'success');
                        } else {
                            showToast('Failed to update title: ' + (data.error || 'Unknown error'), 'danger');
                        }
                        
                        // Clean up
                        editContainer.remove();
                        spaceTitle.style.display = '';
                        editTitleBtn.style.display = '';
                    })
                    .catch(error => {
                        console.error('Error updating title:', error);
                        showToast('Error updating title', 'danger');
                        
                        // Clean up
                        editContainer.remove();
                        spaceTitle.style.display = '';
                        editTitleBtn.style.display = '';
                    });
                }
                
                // Cancel function
                function cancelEdit() {
                    editContainer.remove();
                    spaceTitle.style.display = '';
                    editTitleBtn.style.display = '';
                }
                
                // Event listeners
                saveBtn.addEventListener('click', saveTitle);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // Enter to save, Escape to cancel
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveTitle();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
            });
        }
        
        // Fetch metadata functionality
        const fetchMetadataBtn = document.getElementById('fetch-metadata-btn');
        if (fetchMetadataBtn && !fetchMetadataBtn.disabled) {
            fetchMetadataBtn.addEventListener('click', function() {
                // Check if already disabled (metadata exists)
                if (fetchMetadataBtn.disabled) {
                    return;
                }
                
                // Disable button and show loading state
                fetchMetadataBtn.disabled = true;
                const originalHTML = fetchMetadataBtn.innerHTML;
                fetchMetadataBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Fetching...';
                
                // Make API request to fetch metadata
                fetch(`/api/space/${window.spaceId}/metadata`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showToast('Metadata fetched successfully', 'success');
                        // Reload page to show the new metadata
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        showToast('Failed to fetch metadata: ' + (data.error || 'Unknown error'), 'danger');
                        // Reset button
                        fetchMetadataBtn.disabled = false;
                        fetchMetadataBtn.innerHTML = originalHTML;
                    }
                })
                .catch(error => {
                    console.error('Error fetching metadata:', error);
                    showToast('Error fetching metadata', 'danger');
                    // Reset button
                    fetchMetadataBtn.disabled = false;
                    fetchMetadataBtn.innerHTML = originalHTML;
                });
            });
        }

    // Smart download button functionality
    function initializeSmartDownloadButton() {
        const downloadContainer = document.getElementById('download-container');
        const spaceId = window.spaceId || '{{ space.space_id }}';
        
        // Fetch available download formats
        fetch(`/api/spaces/${spaceId}/available-formats`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.formats.length > 0) {
                    updateDownloadButton(data.formats);
                } else {
                    console.log('No download formats available');
                }
            })
            .catch(error => {
                console.error('Error fetching download formats:', error);
            });
    }

    function updateDownloadButton(formats) {
        const downloadContainer = document.getElementById('download-container');
        const spaceId = window.spaceId || '{{ space.space_id }}';
        
        if (formats.length === 1) {
            // Single format - show simple button
            const format = formats[0];
            downloadContainer.innerHTML = `
                <a href="/download/${spaceId}?attachment=1&format=${format.format}" 
                   class="btn btn-primary btn-sm text-white" 
                   data-bs-toggle="tooltip" 
                   data-bs-placement="top" 
                   title="Download ${format.name} (${format.size_formatted})">
                    <i class="${format.icon}"></i> <span class="d-none d-sm-inline">Download</span>
                </a>
            `;
        } else {
            // Multiple formats - show dropdown
            let dropdownItems = '';
            formats.forEach(format => {
                dropdownItems += `
                    <li>
                        <a class="dropdown-item" href="/download/${spaceId}?attachment=1&format=${format.format}">
                            <i class="${format.icon} me-2"></i>${format.name} 
                            <small class="text-muted">(${format.size_formatted})</small>
                        </a>
                    </li>
                `;
            });
            
            downloadContainer.innerHTML = `
                <div class="btn-group">
                    <a href="/download/${spaceId}?attachment=1&format=${formats[0].format}" 
                       class="btn btn-primary btn-sm text-white">
                        <i class="bi bi-download"></i> <span class="d-none d-sm-inline">Download</span>
                    </a>
                    <button type="button" 
                            class="btn btn-primary btn-sm dropdown-toggle dropdown-toggle-split text-white" 
                            data-bs-toggle="dropdown" 
                            aria-expanded="false"
                            data-bs-auto-close="true">
                        <span class="visually-hidden">Toggle Dropdown</span>
                    </button>
                    <ul class="dropdown-menu">
                        ${dropdownItems}
                    </ul>
                </div>
            `;
        }
        
        // Re-initialize tooltips for new elements
        const newTooltips = downloadContainer.querySelectorAll('[data-bs-toggle="tooltip"]');
        newTooltips.forEach(element => {
            new bootstrap.Tooltip(element);
        });
    }

    // Move Plyr player variables to global scope for the first script block
    window.mainPlayer = null;
    window.trimPlayer = null;
</script>

<!-- Load Plyr JS -->
<script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>

<!-- Initialize Plyr Players -->
<script>
    // Wait for Plyr to load
    function initializePlyrPlayers() {
        if (typeof Plyr === 'undefined') {
            console.log('Waiting for Plyr to load...');
            setTimeout(initializePlyrPlayers, 100);
            return;
        }
        
        console.log('Plyr loaded, initializing players...');
        
        // Initialize main audio player
        const mainAudioElement = document.getElementById('audio-player');
        console.log('Main audio element found:', !!mainAudioElement);
        
        if (mainAudioElement && typeof Plyr !== 'undefined') {
            try {
                // Different controls for mobile vs desktop
                const isMobile = window.innerWidth <= 768;
                const controls = isMobile ? [
                    'play-large',
                    'play',
                    'progress',
                    'current-time',
                    'duration',
                    'mute',
                    'settings'
                ] : [
                    'play-large',
                    'restart',
                    'play',
                    'progress',
                    'current-time',
                    'duration',
                    'mute',
                    'volume',
                    'settings',
                    'fullscreen'
                ];
                
                window.mainPlayer = new Plyr(mainAudioElement, {
                controls: controls,
                settings: ['speed', 'loop'],
                speed: { selected: 1, options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2] },
                hideControls: false,
                clickToPlay: true,
                keyboard: { focused: true, global: false },
                tooltips: { controls: true, seek: true },
                // Reduce buffer to prevent excessive range requests
                mediaMetadata: {
                    title: '{{ space.title|default(space.space_id) }}'
                },
                // Optimize for streaming
                invertTime: false,
                seekTime: 10
            });
            
            // Add custom styling
            window.mainPlayer.on('ready', function() {
                // updatePlayerInfo function is in the other script block
                if (typeof updatePlayerInfo === 'function') {
                    updatePlayerInfo();
                }
            });
            
            window.mainPlayer.on('timeupdate', function() {
                // updateTimeDisplay function is in the other script block
                if (typeof updateTimeDisplay === 'function') {
                    updateTimeDisplay();
                }
            });
            
            console.log('Main Plyr player initialized successfully');
            } catch (error) {
                console.error('Error initializing main Plyr player:', error);
            }
        } else if (!mainAudioElement) {
            console.warn('Main audio element not found');
        } else if (typeof Plyr === 'undefined') {
            console.error('Plyr library not loaded');
        }
        
        // Initialize trim modal audio player
        const trimAudioElement = document.getElementById('trim-audio-preview');
        if (trimAudioElement && typeof Plyr !== 'undefined') {
            try {
                window.trimPlayer = new Plyr(trimAudioElement, {
                controls: [
                    'play',
                    'progress',
                    'current-time',
                    'duration',
                    'mute',
                    'volume'
                ],
                hideControls: false,
                clickToPlay: true,
                keyboard: { focused: true, global: false },
                tooltips: { controls: true, seek: true }
            });
                console.log('Trim Plyr player initialized successfully');
            } catch (error) {
                console.error('Error initializing trim Plyr player:', error);
            }
        }
    }
    
    // Initialize on DOMContentLoaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializePlyrPlayers);
    } else {
        // DOM already loaded
        initializePlyrPlayers();
    }
    
    // Helper function to get the actual media element
    window.getMediaElement = function(player) {
        return player ? player.media : null;
    }
</script>

<!-- Load SummerNote JS -->
<script src="https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote-lite.min.js"></script>

<script>
    // Notes functionality
    $(document).ready(function() {
        // Simple toast function for notes (in case the main one isn't loaded yet)
        function showToast(message, type = 'info') {
            // Create toast element
            const toastId = 'toast-' + Date.now();
            const toastHtml = `
                <div id="${toastId}" class="toast align-items-center text-white bg-${type === 'success' ? 'success' : type === 'danger' ? 'danger' : 'primary'} border-0" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="d-flex">
                        <div class="toast-body">
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                </div>
            `;
            
            // Add to container or create one
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                container.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                container.style.zIndex = '11';
                document.body.appendChild(container);
            }
            
            container.insertAdjacentHTML('beforeend', toastHtml);
            
            // Initialize and show toast
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement);
            toast.show();
            
            // Remove after hidden
            toastElement.addEventListener('hidden.bs.toast', () => {
                toastElement.remove();
            });
        }
        
        const spaceId = window.spaceId || '{{ space.space_id }}';
        let currentNoteId = null;
        
        // Function to get or create cookie ID
        
        // Initialize SummerNote
        $('#note-editor').summernote({
            placeholder: 'Write your notes here...',
            tabsize: 2,
            height: 300,
            toolbar: [
                ['style', ['style']],
                ['font', ['bold', 'underline', 'clear']],
                ['color', ['color']],
                ['para', ['ul', 'ol', 'paragraph']],
                ['table', ['table']],
                ['insert', ['link', 'picture', 'video']],
                ['view', ['fullscreen', 'codeview']]
            ],
            callbacks: {
                onPaste: function(e) {
                    const clipboardData = e.originalEvent.clipboardData;
                    if (clipboardData && clipboardData.getData) {
                        const pastedData = clipboardData.getData('Text');
                        
                        // Check if it's a YouTube URL
                        const youtubeRegex = /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})$/;
                        const match = pastedData.trim().match(youtubeRegex);
                        
                        if (match) {
                            e.preventDefault();
                            const videoId = match[1];
                            const embedHtml = `
                                <div class="youtube-embed" style="margin-bottom: 1rem;">
                                    <a href="https://www.youtube.com/watch?v=${videoId}" target="_blank">
                                        <img src="https://img.youtube.com/vi/${videoId}/maxresdefault.jpg" 
                                             alt="YouTube Video" 
                                             style="max-width: 100%; height: auto; cursor: pointer;"
                                             onerror="this.src='https://img.youtube.com/vi/${videoId}/hqdefault.jpg'">
                                    </a>
                                    <p><a href="https://www.youtube.com/watch?v=${videoId}" target="_blank">Watch on YouTube</a></p>
                                </div>`;
                            $('#note-editor').summernote('pasteHTML', embedHtml);
                        }
                    }
                }
            }
        });
        
        // Load notes
        function loadNotes() {
            const cookieId = window.getCookieId();
            fetch(`/api/spaces/${spaceId}/notes?cookie_id=${cookieId}`)
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('notes-container');
                    if (data.notes && data.notes.length > 0) {
                        let notesHtml = '';
                        data.notes.forEach(note => {
                            notesHtml += `
                                <div class="note-item mb-3 p-3 border rounded" data-note-id="${note.id}">
                                    <div class="note-content">${note.notes}</div>
                                    <div class="note-meta mt-2 d-flex justify-content-between align-items-center">
                                        <small class="text-muted">
                                            by <strong>${note.author}</strong> • 
                                            Last updated: ${new Date(note.updated_at).toLocaleString()}
                                        </small>
                                        ${note.can_edit ? `
                                        <div>
                                            <button class="btn btn-sm btn-outline-primary edit-note-btn" data-note-id="${note.id}" title="Edit note">
                                                <i class="bi bi-pencil"></i>
                                            </button>
                                            <button class="btn btn-sm btn-outline-danger delete-note-btn" data-note-id="${note.id}" title="Delete note">
                                                <i class="bi bi-trash"></i>
                                            </button>
                                        </div>` : ''}
                                    </div>
                                </div>`;
                        });
                        container.innerHTML = notesHtml;
                        
                        // Attach event listeners
                        attachNoteEventListeners();
                    } else {
                        container.innerHTML = '<p class="text-muted text-center">No notes yet. Click "Add Note" to create your first note.</p>';
                    }
                })
                .catch(error => {
                    console.error('Error loading notes:', error);
                    document.getElementById('notes-container').innerHTML = '<p class="text-danger">Error loading notes.</p>';
                });
        }
        
        // Attach event listeners to note buttons
        function attachNoteEventListeners() {
            // Edit buttons
            document.querySelectorAll('.edit-note-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const noteId = this.getAttribute('data-note-id');
                    const noteItem = document.querySelector(`.note-item[data-note-id="${noteId}"]`);
                    const noteContent = noteItem.querySelector('.note-content').innerHTML;
                    
                    currentNoteId = noteId;
                    $('#note-editor').summernote('code', noteContent);
                    document.getElementById('note-editor-container').style.display = 'block';
                    document.getElementById('add-note-btn').style.display = 'none';
                });
            });
            
            // Delete buttons
            document.querySelectorAll('.delete-note-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to delete this note?')) {
                        const noteId = this.getAttribute('data-note-id');
                        deleteNote(noteId);
                    }
                });
            });
        }
        
        // Save note
        function saveNote() {
            const content = $('#note-editor').summernote('code');
            if (!content || !content.trim() || content === '<p><br></p>') {
                showToast('Please enter some content', 'warning');
                return;
            }
            
            const cookieId = window.getCookieId();
            const url = currentNoteId 
                ? `/api/spaces/${spaceId}/notes/${currentNoteId}`
                : `/api/spaces/${spaceId}/notes`;
            const method = currentNoteId ? 'PUT' : 'POST';
            
            fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    notes: content,
                    cookie_id: cookieId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Note saved successfully', 'success');
                    $('#note-editor').summernote('code', '');
                    document.getElementById('note-editor-container').style.display = 'none';
                    document.getElementById('add-note-btn').style.display = 'block';
                    currentNoteId = null;
                    loadNotes();
                } else {
                    showToast('Failed to save note', 'danger');
                }
            })
            .catch(error => {
                console.error('Error saving note:', error);
                showToast('Error saving note', 'danger');
            });
        }
        
        // Delete note
        function deleteNote(noteId) {
            const cookieId = window.getCookieId();
            fetch(`/api/spaces/${spaceId}/notes/${noteId}?cookie_id=${cookieId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Note deleted successfully', 'success');
                    loadNotes();
                } else {
                    showToast('Failed to delete note', 'danger');
                }
            })
            .catch(error => {
                console.error('Error deleting note:', error);
                showToast('Error deleting note', 'danger');
            });
        }
        
        // Event listeners
        const addNoteBtn = document.getElementById('add-note-btn');
        const saveNoteBtn = document.getElementById('save-note-btn');
        const cancelNoteBtn = document.getElementById('cancel-note-btn');
        
        if (addNoteBtn) {
            addNoteBtn.addEventListener('click', function() {
                currentNoteId = null;
                $('#note-editor').summernote('code', '');
                document.getElementById('note-editor-container').style.display = 'block';
                this.style.display = 'none';
            });
        }
        
        if (saveNoteBtn) {
            saveNoteBtn.addEventListener('click', saveNote);
        }
        
        if (cancelNoteBtn) {
            cancelNoteBtn.addEventListener('click', function() {
                $('#note-editor').summernote('code', '');
                document.getElementById('note-editor-container').style.display = 'none';
                if (addNoteBtn) addNoteBtn.style.display = 'block';
                currentNoteId = null;
            });
        }
        
        // Load notes on page load
        loadNotes();
        
        // Trim Audio Functionality
        const trimStartMin = document.getElementById('trim-start-min');
        const trimStartSec = document.getElementById('trim-start-sec');
        const trimEndMin = document.getElementById('trim-end-min');
        const trimEndSec = document.getElementById('trim-end-sec');
        const trimDuration = document.getElementById('trim-duration');
        const trimRange = document.getElementById('trim-range');
        const applyTrimBtn = document.getElementById('apply-trim-btn');
        const setCurrentStartBtn = document.getElementById('set-current-start');
        const setCurrentEndBtn = document.getElementById('set-current-end');
        
        // Format time for display
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update trim info display
        function updateTrimInfo() {
            const startTime = parseInt(trimStartMin.value || 0) * 60 + parseInt(trimStartSec.value || 0);
            const endTime = parseInt(trimEndMin.value || 0) * 60 + parseInt(trimEndSec.value || 0);
            
            if (trimPlayer && trimPlayer.duration) {
                const duration = trimPlayer.duration;
                const actualEndTime = (endTime === 0) ? duration : Math.min(endTime, duration);
                
                if (startTime < actualEndTime) {
                    const trimmedDuration = actualEndTime - startTime;
                    trimDuration.textContent = formatTime(trimmedDuration);
                    trimRange.textContent = `${formatTime(startTime)} to ${formatTime(actualEndTime)}`;
                } else {
                    trimDuration.textContent = 'Invalid range';
                    trimRange.textContent = 'Invalid range';
                }
            }
        }
        
        // Set current time buttons
        if (setCurrentStartBtn) {
            setCurrentStartBtn.addEventListener('click', function() {
                if (trimPlayer && trimPlayer.currentTime) {
                    const time = Math.floor(trimPlayer.currentTime);
                    trimStartMin.value = Math.floor(time / 60);
                    trimStartSec.value = time % 60;
                    updateTrimInfo();
                }
            });
        }
        
        if (setCurrentEndBtn) {
            setCurrentEndBtn.addEventListener('click', function() {
                if (trimPlayer && trimPlayer.currentTime) {
                    const time = Math.floor(trimPlayer.currentTime);
                    trimEndMin.value = Math.floor(time / 60);
                    trimEndSec.value = time % 60;
                    updateTrimInfo();
                }
            });
        }
        
        // Update info when values change
        [trimStartMin, trimStartSec, trimEndMin, trimEndSec].forEach(input => {
            if (input) {
                input.addEventListener('input', updateTrimInfo);
            }
        });
        
        // Set end time to duration when modal opens
        const trimModal = document.getElementById('trimModal');
        if (trimModal) {
            trimModal.addEventListener('show.bs.modal', function() {
                // Wait for audio to load
                setTimeout(() => {
                    if (trimPlayer && trimPlayer.duration) {
                        const duration = Math.floor(trimPlayer.duration);
                        trimEndMin.value = Math.floor(duration / 60);
                        trimEndSec.value = duration % 60;
                        updateTrimInfo();
                    }
                }, 500);
            });
        }
        
        // Apply trim
        if (applyTrimBtn) {
            applyTrimBtn.addEventListener('click', function() {
                const startTime = parseInt(trimStartMin.value || 0) * 60 + parseInt(trimStartSec.value || 0);
                const endTime = parseInt(trimEndMin.value || 0) * 60 + parseInt(trimEndSec.value || 0);
                
                if (startTime >= endTime && endTime !== 0) {
                    showToast('End time must be after start time', 'warning');
                    return;
                }
                
                // Confirm action
                if (!confirm('This will permanently modify the audio file. Are you sure you want to continue?')) {
                    return;
                }
                
                // Disable button and show loading
                applyTrimBtn.disabled = true;
                applyTrimBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Trimming...';
                
                // Send trim request
                const cookieId = window.getCookieId();
                fetch(`/api/spaces/${spaceId}/trim`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        start_time: startTime,
                        end_time: endTime || null,  // null means end of file
                        cookie_id: cookieId
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showToast('Audio trimmed successfully', 'success');
                        // Close modal
                        const modalInstance = bootstrap.Modal.getInstance(trimModal);
                        if (modalInstance) modalInstance.hide();
                        // Reload page to refresh audio
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);
                    } else {
                        showToast(data.error || 'Failed to trim audio', 'danger');
                        applyTrimBtn.disabled = false;
                        applyTrimBtn.innerHTML = '<i class="bi bi-scissors"></i> Apply Trim';
                    }
                })
                .catch(error => {
                    console.error('Error trimming audio:', error);
                    showToast('Error trimming audio', 'danger');
                    applyTrimBtn.disabled = false;
                    applyTrimBtn.innerHTML = '<i class="bi bi-scissors"></i> Apply Trim';
                });
            });
        }
        
        // Share functionality
        const shareBtn = document.getElementById('share-btn');
        const shareModal = document.getElementById('shareModal');
        const copyShareBtn = document.getElementById('copy-share-btn');
        const shareMessage = document.getElementById('share-message');
        
        if (shareBtn && shareModal) {
            // Initialize share modal
            const shareModalInstance = new bootstrap.Modal(shareModal);
            
            shareBtn.addEventListener('click', function() {
                // Update share links
                const message = shareMessage.value;
                const url = window.location.href;
                const encodedMessage = encodeURIComponent(message);
                const encodedUrl = encodeURIComponent(url);
                
                // Twitter/X
                document.getElementById('share-twitter').href = 
                    `https://twitter.com/intent/tweet?text=${encodedMessage}`;
                
                // Facebook
                document.getElementById('share-facebook').href = 
                    `https://www.facebook.com/sharer/sharer.php?u=${encodedUrl}&quote=${encodedMessage}`;
                
                // WhatsApp
                document.getElementById('share-whatsapp').href = 
                    `https://wa.me/?text=${encodedMessage}`;
                
                // Telegram
                document.getElementById('share-telegram').href = 
                    `https://t.me/share/url?url=${encodedUrl}&text=${message.split('\n\n')[0]}`;
                
                // Show modal
                shareModalInstance.show();
            });
            
            // Copy to clipboard
            if (copyShareBtn) {
                copyShareBtn.addEventListener('click', function() {
                    shareMessage.select();
                    shareMessage.setSelectionRange(0, 99999); // For mobile devices
                    
                    try {
                        document.execCommand('copy');
                        
                        // Change button text temporarily
                        const originalHTML = this.innerHTML;
                        this.innerHTML = '<i class="bi bi-check"></i> Copied!';
                        this.classList.remove('btn-primary');
                        this.classList.add('btn-success');
                        
                        setTimeout(() => {
                            this.innerHTML = originalHTML;
                            this.classList.remove('btn-success');
                            this.classList.add('btn-primary');
                        }, 2000);
                        
                        showToast('Share message copied to clipboard!', 'success');
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                        showToast('Failed to copy to clipboard', 'danger');
                    }
                });
            }
        }
        
        // Reviews functionality
        let currentReviewId = null;
        let selectedRating = 0;
        
        // Star rating interaction
        const starRating = document.getElementById('star-rating');
        const reviewRating = document.getElementById('review-rating');
        const stars = starRating ? starRating.querySelectorAll('i') : [];
        
        stars.forEach((star, index) => {
            star.addEventListener('click', function() {
                selectedRating = index + 1;
                reviewRating.value = selectedRating;
                updateStarDisplay();
            });
            
            star.addEventListener('mouseenter', function() {
                // Show hover state
                stars.forEach((s, i) => {
                    if (i <= index) {
                        s.classList.remove('bi-star');
                        s.classList.add('bi-star-fill');
                    } else {
                        s.classList.remove('bi-star-fill');
                        s.classList.add('bi-star');
                    }
                });
            });
        });
        
        if (starRating) {
            starRating.addEventListener('mouseleave', function() {
                updateStarDisplay();
            });
        }
        
        function updateStarDisplay() {
            stars.forEach((star, index) => {
                if (index < selectedRating) {
                    star.classList.remove('bi-star');
                    star.classList.add('bi-star-fill');
                } else {
                    star.classList.remove('bi-star-fill');
                    star.classList.add('bi-star');
                }
            });
        }
        
        // Load reviews
        function loadReviews() {
            const cookieId = window.getCookieId();
            fetch(`/api/spaces/${spaceId}/reviews?cookie_id=${cookieId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update summary
                        document.getElementById('average-rating').textContent = data.average_rating.toFixed(1);
                        document.getElementById('total-reviews').textContent = data.total_reviews;
                        
                        // Display average stars
                        const avgStarsContainer = document.getElementById('average-stars');
                        avgStarsContainer.innerHTML = '';
                        for (let i = 1; i <= 5; i++) {
                            if (i <= Math.floor(data.average_rating)) {
                                avgStarsContainer.innerHTML += '<i class="bi bi-star-fill"></i>';
                            } else if (i - 0.5 <= data.average_rating) {
                                avgStarsContainer.innerHTML += '<i class="bi bi-star-half"></i>';
                            } else {
                                avgStarsContainer.innerHTML += '<i class="bi bi-star"></i>';
                            }
                        }
                        
                        // Display reviews
                        const container = document.getElementById('reviews-container');
                        if (data.reviews && data.reviews.length > 0) {
                            let reviewsHtml = '';
                            data.reviews.forEach(review => {
                                reviewsHtml += `
                                    <div class="review-item" data-review-id="${review.id}">
                                        <div class="d-flex justify-content-between align-items-start">
                                            <div class="flex-grow-1">
                                                <div class="d-flex align-items-center gap-2 mb-1">
                                                    <strong>${review.author}</strong>
                                                    <div class="review-stars">
                                                        ${Array(5).fill('').map((_, i) => 
                                                            i < review.rating ? '<i class="bi bi-star-fill"></i>' : '<i class="bi bi-star"></i>'
                                                        ).join('')}
                                                    </div>
                                                </div>
                                                ${review.review ? `<p class="mb-1">${review.review}</p>` : ''}
                                                <small class="text-muted">
                                                    ${new Date(review.created_at).toLocaleDateString()}
                                                    ${review.updated_at !== review.created_at ? ' (edited)' : ''}
                                                </small>
                                            </div>
                                            ${review.can_edit || review.can_delete ? `
                                                <div class="dropdown">
                                                    <button class="btn btn-link btn-sm" type="button" data-bs-toggle="dropdown">
                                                        <i class="bi bi-three-dots-vertical"></i>
                                                    </button>
                                                    <ul class="dropdown-menu dropdown-menu-end">
                                                        ${review.can_edit ? `
                                                            <li><a class="dropdown-item edit-review" href="#" data-review-id="${review.id}" data-rating="${review.rating}" data-review="${review.review || ''}">
                                                                <i class="bi bi-pencil"></i> Edit
                                                            </a></li>
                                                        ` : ''}
                                                        ${review.can_delete ? `
                                                            <li><a class="dropdown-item delete-review text-danger" href="#" data-review-id="${review.id}">
                                                                <i class="bi bi-trash"></i> Delete
                                                            </a></li>
                                                        ` : ''}
                                                    </ul>
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                `;
                            });
                            container.innerHTML = reviewsHtml;
                            
                            // Attach event listeners
                            container.querySelectorAll('.edit-review').forEach(btn => {
                                btn.addEventListener('click', editReview);
                            });
                            container.querySelectorAll('.delete-review').forEach(btn => {
                                btn.addEventListener('click', deleteReview);
                            });
                        } else {
                            container.innerHTML = '<p class="text-muted">No reviews yet. Be the first to review this space!</p>';
                        }
                        
                        // Check if user already reviewed
                        const hasReviewed = data.reviews.some(r => r.can_edit);
                        const addReviewBtn = document.getElementById('add-review-btn');
                        if (addReviewBtn) {
                            addReviewBtn.style.display = hasReviewed ? 'none' : 'block';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading reviews:', error);
                    showToast('Error loading reviews', 'danger');
                });
        }
        
        // Add review button
        const addReviewBtn = document.getElementById('add-review-btn');
        if (addReviewBtn) {
            addReviewBtn.addEventListener('click', function() {
                currentReviewId = null;
                selectedRating = 0;
                reviewRating.value = 0;
                document.getElementById('review-text').value = '';
                document.getElementById('review-editor-title').textContent = 'Write a Review';
                updateStarDisplay();
                
                document.getElementById('review-editor-container').style.display = 'block';
                this.style.display = 'none';
            });
        }
        
        // Save review
        const saveReviewBtn = document.getElementById('save-review-btn');
        if (saveReviewBtn) {
            saveReviewBtn.addEventListener('click', function() {
                const rating = parseInt(reviewRating.value);
                const reviewText = document.getElementById('review-text').value.trim();
                const cookieId = window.getCookieId();
                
                if (rating === 0) {
                    showToast('Please select a rating', 'warning');
                    return;
                }
                
                const url = currentReviewId 
                    ? `/api/spaces/${spaceId}/reviews/${currentReviewId}`
                    : `/api/spaces/${spaceId}/reviews`;
                    
                const method = currentReviewId ? 'PUT' : 'POST';
                
                fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rating: rating,
                        review: reviewText,
                        cookie_id: cookieId
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success || data.review_id) {
                        showToast(currentReviewId ? 'Review updated successfully' : 'Review added successfully', 'success');
                        document.getElementById('review-editor-container').style.display = 'none';
                        if (addReviewBtn) addReviewBtn.style.display = 'block';
                        loadReviews();
                    } else {
                        showToast(data.error || 'Failed to save review', 'danger');
                    }
                })
                .catch(error => {
                    console.error('Error saving review:', error);
                    showToast('Error saving review', 'danger');
                });
            });
        }
        
        // Cancel review
        const cancelReviewBtn = document.getElementById('cancel-review-btn');
        if (cancelReviewBtn) {
            cancelReviewBtn.addEventListener('click', function() {
                document.getElementById('review-editor-container').style.display = 'none';
                if (addReviewBtn && !currentReviewId) {
                    addReviewBtn.style.display = 'block';
                }
                currentReviewId = null;
            });
        }
        
        // Edit review
        function editReview(e) {
            e.preventDefault();
            const reviewId = this.dataset.reviewId;
            const rating = parseInt(this.dataset.rating);
            const reviewText = this.dataset.review;
            
            currentReviewId = reviewId;
            selectedRating = rating;
            reviewRating.value = rating;
            document.getElementById('review-text').value = reviewText;
            document.getElementById('review-editor-title').textContent = 'Edit Review';
            updateStarDisplay();
            
            document.getElementById('review-editor-container').style.display = 'block';
            if (addReviewBtn) addReviewBtn.style.display = 'none';
            
            // Scroll to editor
            document.getElementById('review-editor-container').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Delete review
        function deleteReview(e) {
            e.preventDefault();
            const reviewId = this.dataset.reviewId;
            
            if (!confirm('Are you sure you want to delete this review?')) {
                return;
            }
            
            const cookieId = window.getCookieId();
            fetch(`/api/spaces/${spaceId}/reviews/${reviewId}?cookie_id=${cookieId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Review deleted successfully', 'success');
                    loadReviews();
                } else {
                    showToast(data.error || 'Failed to delete review', 'danger');
                }
            })
            .catch(error => {
                console.error('Error deleting review:', error);
                showToast('Error deleting review', 'danger');
            });
        }
        
        // Load reviews on page load
        loadReviews();
        
        // Favorite button functionality
        const favoriteBtn = document.getElementById('favorite-btn');
        if (favoriteBtn) {
            favoriteBtn.addEventListener('click', function() {
                const cookieId = window.getCookieId();
                const isCurrentlyFavorite = this.classList.contains('btn-warning');
                
                // Disable button during request
                this.disabled = true;
                
                fetch(`/api/spaces/${spaceId}/favorite`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ cookie_id: cookieId })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update button appearance
                        if (data.is_favorite) {
                            this.classList.remove('btn-outline-warning');
                            this.classList.add('btn-warning');
                            this.querySelector('i').classList.remove('bi-star');
                            this.querySelector('i').classList.add('bi-star-fill');
                            this.title = 'Remove from favorites';
                            showToast('Added to favorites!', 'success');
                        } else {
                            this.classList.remove('btn-warning');
                            this.classList.add('btn-outline-warning');
                            this.querySelector('i').classList.remove('bi-star-fill');
                            this.querySelector('i').classList.add('bi-star');
                            this.title = 'Add to favorites';
                            showToast('Removed from favorites', 'info');
                        }
                    } else {
                        showToast(data.error || 'Failed to update favorite', 'danger');
                    }
                })
                .catch(error => {
                    console.error('Error toggling favorite:', error);
                    showToast('Error updating favorite', 'danger');
                })
                .finally(() => {
                    this.disabled = false;
                });
            });
        }
        
        // Initialize smart download button
        initializeSmartDownloadButton();
        
        // Initialize video generation button
        initializeVideoGeneration();
        
        // Video generation functionality
        let currentVideoPollingInterval = null;
        
        function initializeVideoGeneration() {
            const generateBtn = document.getElementById('generate-video-btn');
            const spaceId = window.spaceId || '{{ space.space_id }}';
            
            if (generateBtn) {
                // Check if video already exists
                checkExistingVideo(spaceId, generateBtn);
                
                generateBtn.addEventListener('click', function() {
                    // Only generate if button is not in "ready" state
                    if (!generateBtn.classList.contains('btn-success')) {
                        generateVideo(spaceId);
                    }
                });
            }
        }

        function checkExistingVideo(spaceId, generateBtn) {
            fetch(`/api/spaces/${spaceId}/available-formats`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.formats) {
                        const hasMP4 = data.formats.some(format => format.format === 'mp4');
                        if (hasMP4) {
                            // Video already exists, update button to show it's ready
                            generateBtn.innerHTML = '<i class="bi bi-camera-video-fill"></i> <span class="d-none d-sm-inline">Video Ready</span>';
                            generateBtn.className = 'btn btn-success btn-sm';
                            generateBtn.title = 'Video is ready! Use the download button to get your MP4.';
                            generateBtn.disabled = false;
                        }
                    }
                })
                .catch(error => {
                    console.debug('Error checking existing video:', error);
                });
        }

        function generateVideo(spaceId) {
            const generateBtn = document.getElementById('generate-video-btn');
            const originalHTML = generateBtn.innerHTML;
            
            // Clear any existing polling interval
            if (currentVideoPollingInterval) {
                clearInterval(currentVideoPollingInterval);
                currentVideoPollingInterval = null;
            }
            
            // Disable button and show loading
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> <span class="d-none d-sm-inline">Generating...</span>';
            
            fetch(`/api/spaces/${spaceId}/generate-video`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Video generation started! This may take a few minutes.', 'success');
                    
                    // Start polling for completion
                    pollVideoStatus(spaceId, data.job_id);
                } else {
                    showToast(`Error: ${data.error}`, 'danger');
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = originalHTML;
                }
            })
            .catch(error => {
                console.error('Error generating video:', error);
                showToast('Error starting video generation', 'danger');
                generateBtn.disabled = false;
                generateBtn.innerHTML = originalHTML;
            });
        }

        function pollVideoStatus(spaceId, jobId) {
            const generateBtn = document.getElementById('generate-video-btn');
            
            // Clear any existing interval
            if (currentVideoPollingInterval) {
                clearInterval(currentVideoPollingInterval);
            }
            
            currentVideoPollingInterval = setInterval(() => {
                fetch(`/api/spaces/${spaceId}/video-status/${jobId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Video status response:', data); // Debug logging
                        
                        // Check if we have job data (the response structure from your example)
                        if (data && data.status) {
                            console.log('Processing status:', data.status); // Debug logging
                            
                            if (data.status === 'completed') {
                                console.log('Video completed, clearing interval'); // Debug logging
                                clearInterval(currentVideoPollingInterval);
                                currentVideoPollingInterval = null;
                                showToast('Video generated successfully!', 'success');
                                
                                // Update button to show download option
                                generateBtn.innerHTML = '<i class="bi bi-camera-video-fill"></i> <span class="d-none d-sm-inline">Video Ready</span>';
                                generateBtn.disabled = false;
                                generateBtn.className = 'btn btn-success btn-sm';
                                generateBtn.title = 'Video is ready! Use the download button to get your MP4.';
                                
                                // Force refresh download button to show MP4 option
                                console.log('Refreshing download button'); // Debug logging
                                setTimeout(() => {
                                    initializeSmartDownloadButton();
                                }, 500);
                                
                                return; // Exit after handling completion
                                
                            } else if (data.status === 'failed') {
                                clearInterval(currentVideoPollingInterval);
                                currentVideoPollingInterval = null;
                                showToast(`Video generation failed: ${data.error || 'Unknown error'}`, 'danger');
                                
                                // Reset button
                                generateBtn.disabled = false;
                                generateBtn.innerHTML = '<i class="bi bi-camera-video"></i> <span class="d-none d-sm-inline">Generate Video</span>';
                                generateBtn.className = 'btn btn-secondary btn-sm';
                                
                                return; // Exit after handling failure
                                
                            } else if (data.status === 'processing') {
                                // Update button with progress
                                const progress = data.progress || 0;
                                generateBtn.innerHTML = `<i class="bi bi-hourglass-split"></i> <span class="d-none d-sm-inline">${progress}%</span>`;
                                return; // Exit after handling processing
                            }
                        } else {
                            console.error('Unexpected response structure:', data);
                        }
                    })
                    .catch(error => {
                        console.error('Error polling video status:', error);
                    });
            }, 2000); // Poll every 2 seconds
            
            // Stop polling after 10 minutes
            setTimeout(() => {
                if (currentVideoPollingInterval) {
                    clearInterval(currentVideoPollingInterval);
                    currentVideoPollingInterval = null;
                }
            }, 600000);
        }
    });

    // Tag Management Functions
    {% if can_edit_space %}
    
    // Show/hide delete buttons on hover
    document.addEventListener('DOMContentLoaded', function() {
        const tagItems = document.querySelectorAll('.tag-item');
        
        tagItems.forEach(item => {
            const deleteBtn = item.querySelector('.tag-delete-btn');
            if (deleteBtn) {
                item.addEventListener('mouseenter', function() {
                    deleteBtn.style.display = 'block';
                });
                
                item.addEventListener('mouseleave', function() {
                    deleteBtn.style.display = 'none';
                });
            }
        });
    });
    
    // Variables for tag removal
    let tagToRemoveId = null;
    let tagToRemoveName = null;
    
    // Show add tag modal
    function showAddTagModal() {
        const modal = new bootstrap.Modal(document.getElementById('addTagModal'));
        document.getElementById('tag-name').value = '';
        modal.show();
        
        // Focus on input when modal is shown
        document.getElementById('addTagModal').addEventListener('shown.bs.modal', function() {
            document.getElementById('tag-name').focus();
        });
    }
    
    // Add tag function
    function addTag() {
        const tagName = document.getElementById('tag-name').value.trim();
        
        if (!tagName) {
            showToast('Please enter a tag name', 'warning');
            return;
        }
        
        if (tagName.length > 50) {
            showToast('Tag name must be 50 characters or less', 'warning');
            return;
        }
        
        // Check if tag already exists
        const existingTags = Array.from(document.querySelectorAll('.tag-item')).map(item => 
            item.getAttribute('data-tag-name').toLowerCase()
        );
        
        if (existingTags.includes(tagName.toLowerCase())) {
            showToast('This tag already exists on this space', 'warning');
            return;
        }
        
        // Send request to add tag
        fetch(`/api/spaces/{{ space.space_id }}/tags`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                tag_name: tagName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Add tag to UI
                addTagToUI(data.tag);
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('addTagModal'));
                modal.hide();
                
                showToast('Tag added successfully', 'success');
            } else {
                showToast(data.error || 'Failed to add tag', 'danger');
            }
        })
        .catch(error => {
            console.error('Error adding tag:', error);
            showToast('Error adding tag', 'danger');
        });
    }
    
    // Add tag to UI
    function addTagToUI(tag) {
        const container = document.getElementById('tags-container');
        
        // Remove "no tags" message if it exists
        const noTagsMsg = container.querySelector('.text-muted');
        if (noTagsMsg) {
            noTagsMsg.remove();
        }
        
        // Create new tag element
        const tagElement = document.createElement('div');
        tagElement.className = 'tag-item position-relative';
        tagElement.setAttribute('data-tag-id', tag.id);
        tagElement.setAttribute('data-tag-name', tag.tag_name);
        
        tagElement.innerHTML = `
            <a href="/spaces/tag/${tag.tag_slug}" 
               class="badge bg-secondary text-decoration-none fs-6 px-3 py-2 tag-link">
                <i class="bi bi-tag"></i> ${tag.tag_name}
            </a>
            <button class="btn btn-sm btn-danger tag-delete-btn position-absolute top-0 end-0 translate-middle rounded-circle p-1" 
                    style="display: none; width: 20px; height: 20px; font-size: 10px;"
                    onclick="confirmRemoveTag(${tag.id}, '${tag.tag_name}', event)"
                    title="Remove tag">
                <i class="bi bi-x"></i>
            </button>
        `;
        
        container.appendChild(tagElement);
        
        // Add hover events to new tag
        const deleteBtn = tagElement.querySelector('.tag-delete-btn');
        tagElement.addEventListener('mouseenter', function() {
            deleteBtn.style.display = 'block';
        });
        
        tagElement.addEventListener('mouseleave', function() {
            deleteBtn.style.display = 'none';
        });
    }
    
    // Show confirmation modal for tag removal
    function confirmRemoveTag(tagId, tagName, event) {
        event.preventDefault();
        event.stopPropagation();
        
        tagToRemoveId = tagId;
        tagToRemoveName = tagName;
        
        document.getElementById('tag-to-remove-name').textContent = tagName;
        
        const modal = new bootstrap.Modal(document.getElementById('confirmRemoveTagModal'));
        modal.show();
    }
    
    // Remove tag function
    function removeTag() {
        if (!tagToRemoveId) {
            return;
        }
        
        // Send request to remove tag
        fetch(`/api/spaces/{{ space.space_id }}/tags/${tagToRemoveId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Remove tag from UI
                const tagElement = document.querySelector(`[data-tag-id="${tagToRemoveId}"]`);
                if (tagElement) {
                    tagElement.remove();
                }
                
                // Check if no tags left
                const container = document.getElementById('tags-container');
                const remainingTags = container.querySelectorAll('.tag-item');
                if (remainingTags.length === 0) {
                    container.innerHTML = '<p class="text-muted mb-0">No tags yet. Click "Add Tag" to add some!</p>';
                }
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('confirmRemoveTagModal'));
                modal.hide();
                
                showToast('Tag removed successfully', 'success');
            } else {
                showToast(data.error || 'Failed to remove tag', 'danger');
            }
        })
        .catch(error => {
            console.error('Error removing tag:', error);
            showToast('Error removing tag', 'danger');
        })
        .finally(() => {
            tagToRemoveId = null;
            tagToRemoveName = null;
        });
    }
    
    // Handle Enter key in add tag modal
    document.getElementById('tag-name').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            addTag();
        }
    });
    
    {% endif %}
</script>
{% endblock %}